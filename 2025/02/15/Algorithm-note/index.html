

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=auto>



<head>
  <meta name="google-site-verification" content="7TXW9ttER52MwKw3U6lTa3NKEZw2koxmAO7iJcMTT8c" />
  <meta name="baidu-site-verification" content="codeva-1kmvb8u2lB" />
  <meta charset="UTF-8">
  <!-- 通过 CDN 引入霞鹜文楷字体 -->
  <link rel="stylesheet" href="https://npm.elemecdn.com/lxgw-wenkai-screen-webfont/style.css" media="print" onload="this.media='all'">
  <link rel="apple-touch-icon" sizes="76x76" href="https://kolin-blog.oss-cn-shanghai.aliyuncs.com/blog/202309302055622.jpg">
  <link rel="icon" href="https://kolin-blog.oss-cn-shanghai.aliyuncs.com/blog/202309302055622.jpg">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Kolin">
  <meta name="keywords" content="">
  
    <meta name="description" content="参考代码随想录提炼解题思想，每日刷题记录与心得">
<meta property="og:type" content="article">
<meta property="og:title" content="LeetCode Notes">
<meta property="og:url" content="https://www.renkelin.vip/2025/02/15/Algorithm-note/index.html">
<meta property="og:site_name" content="Kolin&#39;s space">
<meta property="og:description" content="参考代码随想录提炼解题思想，每日刷题记录与心得">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2025-02-14T16:00:00.000Z">
<meta property="article:modified_time" content="2025-02-15T02:59:46.293Z">
<meta property="article:author" content="Kolin">
<meta property="article:tag" content="Algorithm">
<meta property="article:tag" content="LeetCode">
<meta name="twitter:card" content="summary_large_image">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>LeetCode Notes - Kolin&#39;s space</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"www.renkelin.vip","root":"/","version":"1.9.5-a","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="Kolin's space" type="application/atom+xml">
</head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Kolin&#39;s space</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>Home</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>Archives</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>Categories</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>Tags</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>About</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                <span>Links</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('https://kolin-blog.oss-cn-shanghai.aliyuncs.com/blog/202309302057061.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="LeetCode Notes"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-02-15 00:00" pubdate>
          February 15, 2025 am
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          92k words
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          770 mins
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">LeetCode Notes</h1>
            
            
              <div class="markdown-body">
                
                <h1>算法随想录</h1>
<h2 id="数组">数组</h2>
<h3 id="704-二分查找">704. 二分查找</h3>
<p>区间一般可以定义为两种：左闭右闭 [left, right]，或者左闭右开 [left, right]。</p>
<p>这里采用左闭右闭进行代码实现：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">search</span>(<span class="hljs-params">self, nums, target</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type nums: List[int]</span><br><span class="hljs-string">        :type target: int</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        left = <span class="hljs-number">0</span><br>        right = <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span><br>        <span class="hljs-keyword">while</span> left &lt;= right:<br>            middle = (left + right) // <span class="hljs-number">2</span><br>            <span class="hljs-keyword">if</span> nums[middle] &gt; target:<br>                right = middle - <span class="hljs-number">1</span><br>            <span class="hljs-keyword">elif</span> nums[middle] &lt; target:<br>                left = middle + <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">return</span> middle<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>
<h3 id="27-移除元素">27. 移除元素</h3>
<p>双指针法：通过一个快指针和一个慢指针在一个 for 循环下完成两个 for 循环的工作。</p>
<ul>
<li>快指针：寻找新数组的元素，新数组就是不含有目标元素的数组</li>
<li>慢指针：指向更新新数组下标的位置</li>
</ul>
<p>这里不采用暴力解法，使用双指针实现：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">removeElement</span>(<span class="hljs-params">self, nums, val</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type nums: List[int]</span><br><span class="hljs-string">        :type val: int</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        slow = <span class="hljs-number">0</span><br>        fast = <span class="hljs-number">0</span><br>        size = <span class="hljs-built_in">len</span>(nums)<br>        <span class="hljs-keyword">while</span> fast &lt; size:<br>            <span class="hljs-comment"># slow 用来收集不等于 val 的值，如果 fast 对应值不等于 val，则把它与 slow 替换</span><br>            <span class="hljs-keyword">if</span> nums[fast] != val:<br>                nums[slow] = nums[fast]<br>                slow += <span class="hljs-number">1</span><br>            fast+= <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> slow<br></code></pre></td></tr></table></figure>
<h3 id="977-有序数组的平方">977. 有序数组的平方</h3>
<p>数组是有序的，但负数平方之后可能成为最大数了。所以最大值不是在最左边就是在最右边，不可能是中间。</p>
<p>可以考虑双指针法，left指向最左边，right 指向最右边。</p>
<p>定义一个新的数组，和 A 数组一样大小，让 k 指向 res 数组终止位置。</p>
<p>如果 A[left] * A[left] &lt; A[right] * A[right]，那么 res[k–] = A[right] * A[right]</p>
<p>如果 A[left] * A[left] &gt;= A[right] * A[right]，那么 res[k–] = A[left] * A[left]</p>
<p>以下是代码实现：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">sortedSquares</span>(<span class="hljs-params">self, nums</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type nums: List[int]</span><br><span class="hljs-string">        :rtype: List[int]</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        left = <span class="hljs-number">0</span><br>        right = <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span><br>        k = <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span><br>        res = [<span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;inf&#x27;</span>)] * <span class="hljs-built_in">len</span>(nums)<br><br>        <span class="hljs-keyword">while</span> left &lt;= right:<br>            <span class="hljs-keyword">if</span> nums[left] ** <span class="hljs-number">2</span> &gt; nums[right] ** <span class="hljs-number">2</span>:<br>                res[k] = nums[left] ** <span class="hljs-number">2</span><br>                left += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                res[k] = nums[right] ** <span class="hljs-number">2</span><br>                right -= <span class="hljs-number">1</span><br>            k -= <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure>
<h3 id="209-长度最小的子数组">209. 长度最小的子数组</h3>
<p>不断的调节子序列的起始位置和终止位置</p>
<ul>
<li>窗口内是什么？</li>
<li>如何移动窗口的起始位置？</li>
<li>如何移动窗口的结束位置？</li>
</ul>
<p>窗口：满足其和 &gt;= target 的长度最小的连续数组</p>
<p>起始位置如何移动：如果当前窗口的值大于等于 target 了，窗口就要向前移动了（也就是该缩小了）。</p>
<p>结束位置如何移动：窗口的结束位置就是遍历数组的指针，也就是 for 循环里的索引。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minSubArrayLen</span>(<span class="hljs-params">self, target, nums</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type target: int</span><br><span class="hljs-string">        :type nums: List[int]</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        l = <span class="hljs-built_in">len</span>(nums)<br>        res = <span class="hljs-number">999999</span><br>        start = <span class="hljs-number">0</span><br>        end = <span class="hljs-number">0</span><br>        total = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> end &lt; l:<br>            total += nums[end]<br>            <span class="hljs-keyword">while</span> total &gt;= target:<br>                res = <span class="hljs-built_in">min</span>(res, end - start + <span class="hljs-number">1</span>)<br>                total -= nums[start]<br>                start += <span class="hljs-number">1</span><br>            end += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span> <span class="hljs-keyword">if</span> res == <span class="hljs-number">999999</span> <span class="hljs-keyword">else</span> res <br></code></pre></td></tr></table></figure>
<h3 id="59-螺旋矩阵">59. 螺旋矩阵</h3>
<p>初始化一个 n * n 大小的矩阵 matrix，然后模拟整个内向环绕的填入过程。</p>
<p>模拟顺时针画矩阵的过程</p>
<ul>
<li>填充上行从左到右</li>
<li>填充右列从上到下</li>
<li>填充下行从右到左</li>
<li>填充左列从下到上</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">generateMatrix</span>(<span class="hljs-params">self, n</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type n: int</span><br><span class="hljs-string">        :rtype: List[List[int]]</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-comment"># 定义当前左右上下边界，初始值 num = 1，迭代终止值 target = n * n</span><br>        l, r, t, b = <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>, <span class="hljs-number">0</span> , n - <span class="hljs-number">1</span><br>        matrix = [[<span class="hljs-number">0</span>] * n <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]<br>        num, target = <span class="hljs-number">1</span>, n * n<br>        <br>        <span class="hljs-comment"># 使用 num &lt;= target 而不是 l &lt; r || t &lt; b 作为迭代条件，是为了解决 n 为奇数时，矩阵中心数字无法在迭代过程中被填充的问题</span><br>        <span class="hljs-keyword">while</span> num &lt;= target:<br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(l, r + <span class="hljs-number">1</span>):<br>                matrix[t][i] = num<br>                num += <span class="hljs-number">1</span><br>            t += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(t, b + <span class="hljs-number">1</span>):<br>                matrix[i][r] = num<br>                num += <span class="hljs-number">1</span><br>            r -= <span class="hljs-number">1</span><br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(r, l - <span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):<br>                matrix[b][i] = num<br>                num += <span class="hljs-number">1</span><br>            b -= <span class="hljs-number">1</span><br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(b, t - <span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):<br>                matrix[i][l] = num<br>                num += <span class="hljs-number">1</span><br>            l += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> matrix<br></code></pre></td></tr></table></figure>
<h2 id="链表">链表</h2>
<h3 id="203-移除链表元素">203. 移除链表元素</h3>
<p>链表操作两种方式：</p>
<ul>
<li>直接使用原来的链表来进行删除操作</li>
<li>设置一个虚拟头节点在进行删除操作</li>
</ul>
<p>推荐设置虚拟头节点，这样原链表的所有节点就都可以按照统一的方式进行移除了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Definition for singly-linked list.</span><br><span class="hljs-comment"># class ListNode(object):</span><br><span class="hljs-comment">#     def __init__(self, val=0, next=None):</span><br><span class="hljs-comment">#         self.val = val</span><br><span class="hljs-comment">#         self.next = next</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">removeElements</span>(<span class="hljs-params">self, head, val</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type head: Optional[ListNode]</span><br><span class="hljs-string">        :type val: int</span><br><span class="hljs-string">        :rtype: Optional[ListNode]</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        current = dummy_head = ListNode(<span class="hljs-built_in">next</span> = head)<br>        <span class="hljs-keyword">while</span> current.<span class="hljs-built_in">next</span>:<br>            <span class="hljs-keyword">if</span> current.<span class="hljs-built_in">next</span>.val == val:<br>                current.<span class="hljs-built_in">next</span> = current.<span class="hljs-built_in">next</span>.<span class="hljs-built_in">next</span><br>            <span class="hljs-keyword">else</span>:<br>                current = current.<span class="hljs-built_in">next</span><br>        <span class="hljs-keyword">return</span> dummy_head.<span class="hljs-built_in">next</span><br></code></pre></td></tr></table></figure>
<h3 id="707-设计链表">707. 设计链表</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ListNode</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, val=<span class="hljs-number">0</span>, <span class="hljs-built_in">next</span>=<span class="hljs-literal">None</span></span>):<br>        self.val = val<br>        self.<span class="hljs-built_in">next</span> = <span class="hljs-built_in">next</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyLinkedList</span>(<span class="hljs-title class_ inherited__">object</span>):<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        self.dummy_head = ListNode()<br>        self.size = <span class="hljs-number">0</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get</span>(<span class="hljs-params">self, index</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type index: int</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> index &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> index &gt;= self.size:<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br>        <br>        current = self.dummy_head.<span class="hljs-built_in">next</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(index):<br>            current = current.<span class="hljs-built_in">next</span><br>        <br>        <span class="hljs-keyword">return</span> current.val<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">addAtHead</span>(<span class="hljs-params">self, val</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type val: int</span><br><span class="hljs-string">        :rtype: None</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        self.dummy_head.<span class="hljs-built_in">next</span> = ListNode(val, self.dummy_head.<span class="hljs-built_in">next</span>)<br>        self.size += <span class="hljs-number">1</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">addAtTail</span>(<span class="hljs-params">self, val</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type val: int</span><br><span class="hljs-string">        :rtype: None</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        current = self.dummy_head<br>        <span class="hljs-keyword">while</span> current.<span class="hljs-built_in">next</span>:<br>            current = current.<span class="hljs-built_in">next</span><br>        current.<span class="hljs-built_in">next</span> = ListNode(val)<br>        self.size += <span class="hljs-number">1</span><br>        <br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">addAtIndex</span>(<span class="hljs-params">self, index, val</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type index: int</span><br><span class="hljs-string">        :type val: int</span><br><span class="hljs-string">        :rtype: None</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> index &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> index &gt; self.size:<br>            <span class="hljs-keyword">return</span><br>        <br>        current = self.dummy_head<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(index):<br>            current = current.<span class="hljs-built_in">next</span><br>        current.<span class="hljs-built_in">next</span> = ListNode(val, current.<span class="hljs-built_in">next</span>)<br>        self.size += <span class="hljs-number">1</span><br>        <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">deleteAtIndex</span>(<span class="hljs-params">self, index</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type index: int</span><br><span class="hljs-string">        :rtype: None</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> index &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> index &gt;= self.size:<br>            <span class="hljs-keyword">return</span><br>        <br>        current = self.dummy_head<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(index):<br>            current = current.<span class="hljs-built_in">next</span><br>        <br>        current.<span class="hljs-built_in">next</span> = current.<span class="hljs-built_in">next</span>.<span class="hljs-built_in">next</span><br>        self.size -= <span class="hljs-number">1</span><br>        <br><br><br><span class="hljs-comment"># Your MyLinkedList object will be instantiated and called as such:</span><br><span class="hljs-comment"># obj = MyLinkedList()</span><br><span class="hljs-comment"># param_1 = obj.get(index)</span><br><span class="hljs-comment"># obj.addAtHead(val)</span><br><span class="hljs-comment"># obj.addAtTail(val)</span><br><span class="hljs-comment"># obj.addAtIndex(index,val)</span><br><span class="hljs-comment"># obj.deleteAtIndex(index)</span><br></code></pre></td></tr></table></figure>
<h3 id="206-反转链表">206. 反转链表</h3>
<p>本题采用双指针写法：</p>
<p>首先定义一个 current 指针，指向头节点， 再定义一个 previous 指针，初始化 null。</p>
<p>然后开始反转，首先把 current -&gt; next 节点用 temp 指针保存一下，接下来将 current -&gt; next 指向 previous，此时已经反转了第一个节点了。</p>
<p>接下来循环，继续移动 previous 和 current 指针。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Definition for singly-linked list.</span><br><span class="hljs-comment"># class ListNode(object):</span><br><span class="hljs-comment">#     def __init__(self, val=0, next=None):</span><br><span class="hljs-comment">#         self.val = val</span><br><span class="hljs-comment">#         self.next = next</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">reverseList</span>(<span class="hljs-params">self, head</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type head: Optional[ListNode]</span><br><span class="hljs-string">        :rtype: Optional[ListNode]</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        current, previous = head, <span class="hljs-literal">None</span><br>        <span class="hljs-keyword">while</span> current:<br>            temp = current.<span class="hljs-built_in">next</span>     <span class="hljs-comment"># 暂存后继节点 cur.next</span><br>            current.<span class="hljs-built_in">next</span> = previous <span class="hljs-comment"># 修改 next 引用指向</span><br>            previous = current      <span class="hljs-comment"># pre 暂存 cur</span><br>            current = temp          <span class="hljs-comment"># cur 访问下一节点</span><br>        <span class="hljs-keyword">return</span> previous<br><br></code></pre></td></tr></table></figure>
<h3 id="24-两两交换链表中的节点">24. 两两交换链表中的节点</h3>
<p>建议使用虚拟头节点，这样会方便很多，接下来就是交换相邻两个元素。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Definition for singly-linked list.</span><br><span class="hljs-comment"># class ListNode(object):</span><br><span class="hljs-comment">#     def __init__(self, val=0, next=None):</span><br><span class="hljs-comment">#         self.val = val</span><br><span class="hljs-comment">#         self.next = next</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">swapPairs</span>(<span class="hljs-params">self, head</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type head: Optional[ListNode]</span><br><span class="hljs-string">        :rtype: Optional[ListNode]</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        dummy_head = ListNode(<span class="hljs-built_in">next</span>=head)<br>        current = dummy_head<br><br>        <span class="hljs-keyword">while</span> current.<span class="hljs-built_in">next</span> <span class="hljs-keyword">and</span> current.<span class="hljs-built_in">next</span>.<span class="hljs-built_in">next</span>:<br>            temp1 = current.<span class="hljs-built_in">next</span><br>            temp2 = current.<span class="hljs-built_in">next</span>.<span class="hljs-built_in">next</span>.<span class="hljs-built_in">next</span><br><br>            current.<span class="hljs-built_in">next</span> = current.<span class="hljs-built_in">next</span>.<span class="hljs-built_in">next</span><br>            current.<span class="hljs-built_in">next</span>.<span class="hljs-built_in">next</span> = temp1<br>            temp1.<span class="hljs-built_in">next</span> = temp2<br>            current = current.<span class="hljs-built_in">next</span>.<span class="hljs-built_in">next</span><br>        <span class="hljs-keyword">return</span> dummy_head.<span class="hljs-built_in">next</span> <br></code></pre></td></tr></table></figure>
<h3 id="19-删除链表的倒数第-N-个节点">19. 删除链表的倒数第 N 个节点</h3>
<p>采用双指针，如果要删除倒数第 n 个节点，让 fast 移动 n 步。然后让 fast 和 slow 同时移动，直到 fast 指向链表末尾。删掉 slow 所指向的节点就可以。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Definition for singly-linked list.</span><br><span class="hljs-comment"># class ListNode(object):</span><br><span class="hljs-comment">#     def __init__(self, val=0, next=None):</span><br><span class="hljs-comment">#         self.val = val</span><br><span class="hljs-comment">#         self.next = next</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">removeNthFromEnd</span>(<span class="hljs-params">self, head, n</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type head: Optional[ListNode]</span><br><span class="hljs-string">        :type n: int</span><br><span class="hljs-string">        :rtype: Optional[ListNode]</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-comment"># 创建一个虚拟节点，并将其下一个指针设置为链表的头部</span><br>        dummy_head = ListNode(<span class="hljs-number">0</span>, head)<br><br>        <span class="hljs-comment"># 创建两个指针，慢指针和快指针，并将它们初始化为虚拟节点</span><br>        slow = fast = dummy_head<br><br>        <span class="hljs-comment"># 快指针比慢指针快 n + 1 步</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n + <span class="hljs-number">1</span>):<br>            fast = fast.<span class="hljs-built_in">next</span><br><br>        <span class="hljs-keyword">while</span> fast:<br>            fast = fast.<span class="hljs-built_in">next</span><br>            slow = slow.<span class="hljs-built_in">next</span><br><br>        <span class="hljs-comment"># 通过更新第 (n - 1) 节点的 next 指针删除第 n 个节点</span><br>        slow.<span class="hljs-built_in">next</span> = slow.<span class="hljs-built_in">next</span>.<span class="hljs-built_in">next</span><br><br>        <span class="hljs-keyword">return</span> dummy_head.<span class="hljs-built_in">next</span><br></code></pre></td></tr></table></figure>
<h3 id="142-环形链表Ⅱ">142. 环形链表Ⅱ</h3>
<p>主要考察两知识点：</p>
<ul>
<li>判断链表是否有环</li>
<li>如果有环，如何找到这个环的入口</li>
</ul>
<p>可以使用快慢指针法，分别定义 fast 和 slow 指针，从头节点出发，fast 指针每次移动两个节点，slow 指针每次移动一个节点，如果 fast 指针和 slow 指针在途中相遇，说明这个链表有环。</p>
<p>假设从头节点到环形入口节点的节点数为 x，环形入口节点到 fast 指针与 slow 指针相遇节点节点数为 y，从相遇节点再到环形入口节点数为 z。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Definition for singly-linked list.</span><br><span class="hljs-comment"># class ListNode(object):</span><br><span class="hljs-comment">#     def __init__(self, x):</span><br><span class="hljs-comment">#         self.val = x</span><br><span class="hljs-comment">#         self.next = None</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">detectCycle</span>(<span class="hljs-params">self, head</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type head: ListNode</span><br><span class="hljs-string">        :rtype: ListNode</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        slow = head<br>        fast = head<br><br>        <span class="hljs-keyword">while</span> fast <span class="hljs-keyword">and</span> fast.<span class="hljs-built_in">next</span>:<br>            fast = fast.<span class="hljs-built_in">next</span>.<span class="hljs-built_in">next</span><br>            slow = slow.<span class="hljs-built_in">next</span><br>            <span class="hljs-keyword">if</span> fast == slow:<br>                index1 = fast<br>                index2 = head<br>                <span class="hljs-keyword">while</span> index1 != index2:<br>                    index1 = index1.<span class="hljs-built_in">next</span><br>                    index2 = index2.<span class="hljs-built_in">next</span><br>                <span class="hljs-keyword">return</span> index1<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br></code></pre></td></tr></table></figure>
<h2 id="哈希表">哈希表</h2>
<h3 id="242-有效的字母异位词">242. 有效的字母异位词</h3>
<p>字符 a 到字符 z 的 ASCII 是 26 个连续的数值，所以字符 a 映射为下标 0，相应的字符 z 映射为下标 25。</p>
<p>record 数组中如果有的元素不为 0，说明字符串 s 和 t 一定是谁多了字符或谁少了字符，return False。</p>
<p>如果 record 数组所有元素都为 0，说明字符串 s 和 t 是字母异位词，return True。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">isAnagram</span>(<span class="hljs-params">self, s, t</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type s: str</span><br><span class="hljs-string">        :type t: str</span><br><span class="hljs-string">        :rtype: bool</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        record = [<span class="hljs-number">0</span>] * <span class="hljs-number">26</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> s:<br>            <span class="hljs-comment"># ord()函数的主要功能是将单个字符转换为其对应的Unicode码点</span><br>            record[<span class="hljs-built_in">ord</span>(i) - <span class="hljs-built_in">ord</span>(<span class="hljs-string">&quot;a&quot;</span>)] += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> t:<br>            record[<span class="hljs-built_in">ord</span>(i) - <span class="hljs-built_in">ord</span>(<span class="hljs-string">&quot;a&quot;</span>)] -= <span class="hljs-number">1</span><br>        <br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">26</span>):<br>            <span class="hljs-keyword">if</span>(record[i] != <span class="hljs-number">0</span>):<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure>
<h3 id="349-两个数组的交集">349. 两个数组的交集</h3>
<p>输出结果中的每个元素一定是唯一的，也就是说输出的结果是去重的，同时可以不考虑输出结果的顺序。</p>
<p>使用集合方式:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">intersection</span>(<span class="hljs-params">self, nums1, nums2</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type nums1: List[int]</span><br><span class="hljs-string">        :type nums2: List[int]</span><br><span class="hljs-string">        :rtype: List[int]</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">list</span>(<span class="hljs-built_in">set</span>(nums1) &amp; <span class="hljs-built_in">set</span>(nums2))<br></code></pre></td></tr></table></figure>
<p>使用数组方式：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">intersection</span>(<span class="hljs-params">self, nums1, nums2</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type nums1: List[int]</span><br><span class="hljs-string">        :type nums2: List[int]</span><br><span class="hljs-string">        :rtype: List[int]</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        record = [<span class="hljs-number">0</span>] * <span class="hljs-number">1001</span><br>        result = []<br><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> nums1:<br>            record[i] = <span class="hljs-number">1</span><br><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> nums2:<br>            <span class="hljs-keyword">if</span>(record[i] == <span class="hljs-number">1</span>):<br>                result.append(i)<br>                record[i] = <span class="hljs-number">0</span><br>                <br>        <span class="hljs-keyword">return</span> result<br></code></pre></td></tr></table></figure>
<h3 id="1-两数之和">1. 两数之和</h3>
<p>此题采用 map 映射方法</p>
<p>map 的目的用来存放访问过的元素，因为遍历数组的时候，需要记录之前遍历过哪些元素和对应的下标，这样才能找到与当前元素相匹配的。</p>
<p>map 中的存储结构为 {key：数据元素，value：数组元素对应的下标}</p>
<p>在遍历数组的时候，只需要向 map 去查询是否有和目前遍历数组元素匹配的数值，如果有，就找到的匹配对，如果没有，就把目前遍历的元素放进 map 中，因为 map 存放的就是访问过的元素。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">twoSum</span>(<span class="hljs-params">self, nums, target</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type nums: List[int]</span><br><span class="hljs-string">        :type target: int</span><br><span class="hljs-string">        :rtype: List[int]</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        record = <span class="hljs-built_in">dict</span>()<br><br>        <span class="hljs-keyword">for</span> index, value <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(nums):<br>            <span class="hljs-keyword">if</span> target - value <span class="hljs-keyword">in</span> record:<br>                <span class="hljs-keyword">return</span> [record[target - value], index]<br>            record[value] = index<br>        <span class="hljs-keyword">return</span> []<br></code></pre></td></tr></table></figure>
<h3 id="454-四数相加Ⅱ">454. 四数相加Ⅱ</h3>
<p>四个独立的数组，只要找到 A[i] + B[j] + C[k] + D[i] = 0 就可以，不用考虑有重复的四个元素相加等于 0 的情况。</p>
<ol>
<li>首先定义一个字典，key 存放 num1 和 num2 两数之和，value 存放 num1 和 num2 两数之和出现的次数</li>
<li>遍历 num1 和 num2 数组，统计两个数组元素之和，和出现的次数，放到 map 中</li>
<li>定义变量 count，用来统计 num1 + num2 + num3 + num4 = 0 出现的次数</li>
<li>再遍历 num3 和 num4 数组，找到如果 0 - (num3 + num4) 在 map 中出现过的话，就用 count 把 map 中 key 对应的 value 也就是统计次数统计出来</li>
<li>最后返回统计值 count</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">fourSumCount</span>(<span class="hljs-params">self, nums1, nums2, nums3, nums4</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type nums1: List[int]</span><br><span class="hljs-string">        :type nums2: List[int]</span><br><span class="hljs-string">        :type nums3: List[int]</span><br><span class="hljs-string">        :type nums4: List[int]</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-comment"># 使用字典存储nums1和nums2中的元素及其和</span><br>        hashmap = <span class="hljs-built_in">dict</span>()<br><br>        <span class="hljs-keyword">for</span> n1 <span class="hljs-keyword">in</span> nums1:<br>            <span class="hljs-keyword">for</span> n2 <span class="hljs-keyword">in</span> nums2:<br>                <span class="hljs-keyword">if</span> n1 + n2 <span class="hljs-keyword">in</span> hashmap:<br>                    hashmap[n1 + n2] += <span class="hljs-number">1</span><br>                <span class="hljs-keyword">else</span>:<br>                    hashmap[n1 + n2] = <span class="hljs-number">1</span><br><br>        count = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> n3 <span class="hljs-keyword">in</span> nums3:<br>            <span class="hljs-keyword">for</span> n4 <span class="hljs-keyword">in</span> nums4:<br>                <span class="hljs-comment"># 0 - (c + d) = a + b</span><br>                target = <span class="hljs-number">0</span> - (n3 + n4)<br>                <span class="hljs-keyword">if</span> target <span class="hljs-keyword">in</span> hashmap:<br>                    count += hashmap[target]<br><br>        <span class="hljs-keyword">return</span> count<br></code></pre></td></tr></table></figure>
<h3 id="15-三数之和">15. 三数之和</h3>
<p>使用哈希法并不十分合适，因为在去重的操作中有很多细节需要注意。</p>
<p>采用双指针法，比哈希法高效一些</p>
<p>首先将数组排序，然后有一层 for 循环，i 从下标 0 的地方开始，同时定义一个下标 left 定义在 i + 1 的位置上，定义下标 right 在数组结尾的位置上。</p>
<p>在数组中找到 abc 使得 a + b + c = 0，这里相当于 a = nums[i]，b = nums[left]，c = nums[right]。</p>
<p>如果 nums[i] + nums[left] + nums[right] &gt; 0 说明此时三数之和大了，因为数组是排序后了，所以 right 下标就应该向左移动，这样才能让三数之和小一些。</p>
<p>如果 nums[i] + nums[left] + nums[right] &lt; 0 说明此时三数之和小了，left 就向右移动，才能让三数之和大一些，直到 left 与 right 相遇为止。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">threeSum</span>(<span class="hljs-params">self, nums</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type nums: List[int]</span><br><span class="hljs-string">        :rtype: List[List[int]]</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        result = []<br>        nums.sort()<br>        <br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums)):<br>            <span class="hljs-comment"># 如果当前数字大于0，后面的数字也都大于0，不可能找到和为0的三元组</span><br>            <span class="hljs-keyword">if</span> nums[i] &gt; <span class="hljs-number">0</span>:<br>                <span class="hljs-keyword">break</span><br><br>            <span class="hljs-comment"># 跳过相同的元素以避免重复</span><br>            <span class="hljs-keyword">if</span> i &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> nums[i] == nums[i - <span class="hljs-number">1</span>]:<br>                <span class="hljs-keyword">continue</span><br><br>            left = i + <span class="hljs-number">1</span><br>            right = <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span><br><br>            <span class="hljs-keyword">while</span> right &gt; left:<br>                total = nums[i] + nums[left] + nums[right]<br>                <br>                <span class="hljs-keyword">if</span> total &gt; <span class="hljs-number">0</span>:<br>                    right -= <span class="hljs-number">1</span><br>                <span class="hljs-keyword">elif</span> total &lt; <span class="hljs-number">0</span>:<br>                    left += <span class="hljs-number">1</span><br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-comment"># 将三元组加入结果</span><br>                    result.append([nums[i], nums[left], nums[right]])<br><br>                    <span class="hljs-comment"># 跳过相同的元素以避免重复</span><br>                    <span class="hljs-keyword">while</span> right &gt; left <span class="hljs-keyword">and</span> nums[right] == nums[right - <span class="hljs-number">1</span>]:<br>                        right -= <span class="hljs-number">1</span><br>                    <span class="hljs-keyword">while</span> right &gt; left <span class="hljs-keyword">and</span> nums[left] == nums[left + <span class="hljs-number">1</span>]:<br>                        left += <span class="hljs-number">1</span><br><br>                    right -= <span class="hljs-number">1</span><br>                    left += <span class="hljs-number">1</span><br><br>        <span class="hljs-keyword">return</span> result<br></code></pre></td></tr></table></figure>
<h3 id="18-四数之和">18. 四数之和</h3>
<p>基本解法就是在三数之和的基础上再套一层 for 循环。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">fourSum</span>(<span class="hljs-params">self, nums, target</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type nums: List[int]</span><br><span class="hljs-string">        :type target: int</span><br><span class="hljs-string">        :rtype: List[List[int]]</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        result = []<br>        nums.sort()<br>        n = <span class="hljs-built_in">len</span>(nums)<br><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            <span class="hljs-keyword">if</span> nums[i] &gt; target <span class="hljs-keyword">and</span> nums[i] &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> target &gt; <span class="hljs-number">0</span>:<br>                <span class="hljs-keyword">break</span><br>            <span class="hljs-keyword">if</span> i &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> nums[i] == nums[i - <span class="hljs-number">1</span>]:<br>                <span class="hljs-keyword">continue</span><br>            <br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i + <span class="hljs-number">1</span>, n):<br>                <span class="hljs-keyword">if</span> nums[i] + nums[j] &gt; target <span class="hljs-keyword">and</span> target &gt; <span class="hljs-number">0</span>:<br>                    <span class="hljs-keyword">break</span><br>                <span class="hljs-keyword">if</span> j &gt; i + <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> nums[j] == nums[j - <span class="hljs-number">1</span>]:<br>                    <span class="hljs-keyword">continue</span><br>                left, right = j + <span class="hljs-number">1</span>, n - <span class="hljs-number">1</span><br><br>                <span class="hljs-keyword">while</span> left &lt; right:<br>                    total = nums[i] + nums[j] + nums[left] + nums[right]<br>                    <span class="hljs-keyword">if</span> total == target:<br>                        result.append([nums[i], nums[j], nums[left], nums[right]])<br>                    <br>                        <span class="hljs-keyword">while</span> left &lt; right <span class="hljs-keyword">and</span> nums[left] == nums[left + <span class="hljs-number">1</span>]:<br>                            left += <span class="hljs-number">1</span><br>                        <span class="hljs-keyword">while</span> left &lt; right <span class="hljs-keyword">and</span> nums[right] == nums[right - <span class="hljs-number">1</span>]:<br>                            right -= <span class="hljs-number">1</span><br><br>                        left += <span class="hljs-number">1</span><br>                        right -= <span class="hljs-number">1</span><br>                    <br>                    <span class="hljs-keyword">elif</span> total &lt; target:<br>                        left += <span class="hljs-number">1</span><br>                    <span class="hljs-keyword">else</span>:<br>                        right -= <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> result<br></code></pre></td></tr></table></figure>
<h2 id="字符串">字符串</h2>
<h3 id="344-反转字符串">344. 反转字符串</h3>
<p>采用双指针方法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">reverseString</span>(<span class="hljs-params">self, s</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type s: List[str]</span><br><span class="hljs-string">        :rtype: None Do not return anything, modify s in-place instead.</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        left = <span class="hljs-number">0</span><br>        right = <span class="hljs-built_in">len</span>(s) - <span class="hljs-number">1</span><br><br>        <span class="hljs-keyword">while</span> left &lt; right:<br>            s[left], s[right] = s[right], s[left]<br>            left += <span class="hljs-number">1</span><br>            right -= <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>
<h3 id="541-反转字符串Ⅱ">541. 反转字符串Ⅱ</h3>
<p>在遍历字符串的过程中，只要让 i += (2 * k)，i 每次移动 2 * k 就可以了，然后判断是否需要有反转的区间。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">reverseStr</span>(<span class="hljs-params">self, s, k</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type s: str</span><br><span class="hljs-string">        :type k: int</span><br><span class="hljs-string">        :rtype: str</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">reverse_substring</span>(<span class="hljs-params">text</span>):<br>            left = <span class="hljs-number">0</span><br>            right = <span class="hljs-built_in">len</span>(text) - <span class="hljs-number">1</span><br>            <span class="hljs-keyword">while</span> left &lt; right:<br>                text[left], text[right] = text[right], text[left]<br>                left += <span class="hljs-number">1</span><br>                right -= <span class="hljs-number">1</span><br>            <span class="hljs-keyword">return</span> text<br>        <br>        result = <span class="hljs-built_in">list</span>(s)<br><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(s), <span class="hljs-number">2</span> * k):<br>            result[i: i + k] = reverse_substring(result[i: i + k])<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#x27;</span>.join(result)<br></code></pre></td></tr></table></figure>
<h3 id="151-反转字符串中的单词">151. 反转字符串中的单词</h3>
<p>采用双指针方法</p>
<p>解题思路：</p>
<ul>
<li>移除多余空格</li>
<li>将整个字符串反转</li>
<li>将每个单词反转</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">reverseWords</span>(<span class="hljs-params">self, s</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type s: str</span><br><span class="hljs-string">        :rtype: str</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-comment"># 将字符串拆分为单词，即转换成列表类型</span><br>        words = s.split()<br><br>        left, right = <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(words) - <span class="hljs-number">1</span><br>        <span class="hljs-keyword">while</span> left &lt; right:<br>            words[left], words[right] = words[right], words[left]<br>            left += <span class="hljs-number">1</span><br>            right -= <span class="hljs-number">1</span><br><br>        <span class="hljs-comment"># 将列表转换为字符串</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27; &#x27;</span>.join(words)<br></code></pre></td></tr></table></figure>
<h2 id="栈与队列">栈与队列</h2>
<h3 id="232-用栈实现队列">232. 用栈实现队列</h3>
<p>需要两个栈，<strong>一个输入栈，一个输出栈</strong></p>
<ul>
<li><code>void push(int x)</code> 将元素 x 推到队列的末尾</li>
<li><code>int pop()</code> 从队列的开头移除并返回元素</li>
<li><code>int peek()</code> 返回队列开头的元素</li>
<li><code>boolean empty()</code> 如果队列为空，返回 <code>true</code> ；否则，返回 <code>false</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyQueue</span>(<span class="hljs-title class_ inherited__">object</span>):<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-comment"># in 主要负责 push，out主要负责 pop</span><br>        self.stack_in = []<br>        self.stack_out = []<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">push</span>(<span class="hljs-params">self, x</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type x: int</span><br><span class="hljs-string">        :rtype: None</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-comment"># 有新元素进来，就往 in 里面 push</span><br>        self.stack_in.append(x)<br>        <br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">pop</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> self.empty():<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>        <br>        <span class="hljs-keyword">if</span> self.stack_out:<br>            <span class="hljs-keyword">return</span> self.stack_out.pop()<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(self.stack_in)):<br>                self.stack_out.append(self.stack_in.pop())<br>            <span class="hljs-keyword">return</span> self.stack_out.pop()<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">peek</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        ans = self.pop()<br>        self.stack_out.append(ans)<br>        <span class="hljs-keyword">return</span> ans<br>        <br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">empty</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :rtype: bool</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-comment"># 只要 in 或者 out 有元素，说明队列不为空</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">not</span> (self.stack_in <span class="hljs-keyword">or</span> self.stack_out)<br>        <br><span class="hljs-comment"># Your MyQueue object will be instantiated and called as such:</span><br><span class="hljs-comment"># obj = MyQueue()</span><br><span class="hljs-comment"># obj.push(x)</span><br><span class="hljs-comment"># param_2 = obj.pop()</span><br><span class="hljs-comment"># param_3 = obj.peek()</span><br><span class="hljs-comment"># param_4 = obj.empty()</span><br></code></pre></td></tr></table></figure>
<h3 id="225-用队列实现栈">225. 用队列实现栈</h3>
<p>队列模拟栈，一个队列就够了。</p>
<p>队列是先进先出的规则，把一个队列中的数据导入另一个队列中，数据的顺序并没有变，并没有变成先进后出的规则。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyStack</span>(<span class="hljs-title class_ inherited__">object</span>):<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-comment"># deque 双端队列，支持从两端快速添加和删除元素</span><br>        self.queue = deque()<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">push</span>(<span class="hljs-params">self, x</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type x: int</span><br><span class="hljs-string">        :rtype: None</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        self.queue.append(x)<br>        <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">pop</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> self.empty():<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(self.queue) - <span class="hljs-number">1</span>):<br>            <span class="hljs-comment"># popleft() 方法用于从队列的左侧（开头）删除元素，并返回被删除的元素。</span><br>            self.queue.append(self.queue.popleft())<br>        <span class="hljs-keyword">return</span> self.queue.popleft()<br>        <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">top</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> self.empty():<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(self.queue) - <span class="hljs-number">1</span>):<br>            self.queue.append(self.queue.popleft())<br>        ans = self.queue.popleft()<br>        self.queue.append(ans)<br>        <span class="hljs-keyword">return</span> ans<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">empty</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :rtype: bool</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">not</span> self.queue<br><br><span class="hljs-comment"># Your MyStack object will be instantiated and called as such:</span><br><span class="hljs-comment"># obj = MyStack()</span><br><span class="hljs-comment"># obj.push(x)</span><br><span class="hljs-comment"># param_2 = obj.pop()</span><br><span class="hljs-comment"># param_3 = obj.top()</span><br><span class="hljs-comment"># param_4 = obj.empty()</span><br></code></pre></td></tr></table></figure>
<h3 id="20-有效的括号">20. 有效的括号</h3>
<p>第一种情况：已经遍历完了字符串，但是栈不为空，说明有相应的左括号没有右括号来匹配，所以 return false</p>
<p>第二种情况：遍历字符串匹配的过程中，发现栈里没有要匹配的字符。所以 return false</p>
<p>第三章情况：遍历字符串匹配的过程中，栈已经为空了，没有匹配的字符了，说明右括号没有找到对应的左括号 return false</p>
<p>当字符串全部遍历完之后，栈是空的，说明全部匹配了。</p>
<p>还有一些技巧，右括号先入栈，就只需要比较当前元素和栈顶相不相等就可以了，比左括号先入栈实现要简单很多。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">isValid</span>(<span class="hljs-params">self, s</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type s: str</span><br><span class="hljs-string">        :rtype: bool</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        stack = []<br><br>        <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> s:<br>            <span class="hljs-keyword">if</span> item == <span class="hljs-string">&#x27;(&#x27;</span>:<br>                stack.append(<span class="hljs-string">&#x27;)&#x27;</span>)<br>            <span class="hljs-keyword">elif</span> item == <span class="hljs-string">&#x27;[&#x27;</span>:<br>                stack.append(<span class="hljs-string">&#x27;]&#x27;</span>)<br>            <span class="hljs-keyword">elif</span> item == <span class="hljs-string">&#x27;&#123;&#x27;</span>:<br>                stack.append(<span class="hljs-string">&#x27;&#125;&#x27;</span>)<br>            <span class="hljs-keyword">elif</span> <span class="hljs-keyword">not</span> stack <span class="hljs-keyword">or</span> stack[-<span class="hljs-number">1</span>] != item:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>            <span class="hljs-keyword">else</span>:<br>                stack.pop()<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span> <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> stack <span class="hljs-keyword">else</span> <span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure>
<h3 id="1047-删除字符串中的所有相邻重复项">1047. 删除字符串中的所有相邻重复项</h3>
<p>使用栈来解决</p>
<p>在删除相邻重复项的时候，应该知道当前遍历的这个元素，在前一位是不是遍历过一样数值的元素。</p>
<p>栈的目的就是存放遍历过的元素，当遍历当前的这个元素时，去栈里看看是不是遍历过相同数值的相邻元素。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">removeDuplicates</span>(<span class="hljs-params">self, s</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type s: str</span><br><span class="hljs-string">        :rtype: str</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        res = <span class="hljs-built_in">list</span>()<br><br>        <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> s:<br>            <span class="hljs-keyword">if</span> res <span class="hljs-keyword">and</span> res[-<span class="hljs-number">1</span>] == item:<br>                res.pop()<br>            <span class="hljs-keyword">else</span>:<br>                res.append(item)<br><br>        <span class="hljs-comment"># 字符串拼接</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>.join(res)<br></code></pre></td></tr></table></figure>
<h3 id="150-逆波兰表达式求值">150. 逆波兰表达式求值</h3>
<p>栈与递归之间在某种程度上是可以相互转换的。</p>
<p>逆波兰表达式相当于是二叉树中的后序遍历。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">evalRPN</span>(<span class="hljs-params">self, tokens</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type tokens: List[str]</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        stack = []<br>        <span class="hljs-keyword">for</span> token <span class="hljs-keyword">in</span> tokens:<br>            <span class="hljs-keyword">try</span>:<br>                stack.append(<span class="hljs-built_in">int</span>(token))<br>            <span class="hljs-keyword">except</span>:<br>                num2 = stack.pop()<br>                num1 = stack.pop()<br>                stack.append(self.calculate(num1, num2, token))<br>        <span class="hljs-keyword">return</span> stack[<span class="hljs-number">0</span>]<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">calculate</span>(<span class="hljs-params">self, num1, num2, op</span>):<br>        <span class="hljs-keyword">if</span> op == <span class="hljs-string">&quot;+&quot;</span>:<br>            <span class="hljs-keyword">return</span> num1 + num2<br>        <span class="hljs-keyword">elif</span> op == <span class="hljs-string">&quot;-&quot;</span>:<br>            <span class="hljs-keyword">return</span> num1 - num2<br>        <span class="hljs-keyword">elif</span> op == <span class="hljs-string">&quot;*&quot;</span>:<br>            <span class="hljs-keyword">return</span> num1 * num2<br>        <span class="hljs-keyword">elif</span> op == <span class="hljs-string">&quot;/&quot;</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">int</span>(num1 / <span class="hljs-built_in">float</span>(num2))<br></code></pre></td></tr></table></figure>
<h3 id="239-滑动窗口最大值">239. 滑动窗口最大值</h3>
<p>使用单调队列</p>
<p>队列没有必要维护窗口里的所有元素，只需要维护有可能成为窗口里最大值的元素就可以了，同时保证队列里的元素数值是由大到小的。</p>
<p>设计单调队列的时候，pop 和 push 操作要保持如下规则：</p>
<ol>
<li>pop（value）：如果窗口移除的元素 value 等于单调队列的出口元素，那么队列弹出元素，否则不用任何操作。</li>
<li>push（value）：如果 push 的元素 value 大于入口元素的数值，那么就将队列入口的元素弹出，直到 push 元素的数值小于等于队列入口元素的数值为止。</li>
</ol>
<p>本题采用双端队列实现：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">maxSlidingWindow</span>(<span class="hljs-params">self, nums, k</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type nums: List[int]</span><br><span class="hljs-string">        :type k: int</span><br><span class="hljs-string">        :rtype: List[int]</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        res = []<br>        queue = collections.deque()  <span class="hljs-comment"># 双端队列</span><br>        <span class="hljs-keyword">for</span> i, num <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(nums):<br>            <span class="hljs-comment"># 如果队列最左侧索引已不在滑动窗口范围内，弹出队列最左侧索引</span><br>            <span class="hljs-keyword">if</span> queue <span class="hljs-keyword">and</span> queue[<span class="hljs-number">0</span>] == i - k:<br>                queue.popleft()<br>            <span class="hljs-keyword">while</span> queue <span class="hljs-keyword">and</span> nums[queue[-<span class="hljs-number">1</span>]] &lt; num:<br>                queue.pop()  <span class="hljs-comment"># 维护 queue 的单调性</span><br>            queue.append(i)  <span class="hljs-comment"># 入队</span><br>            <span class="hljs-keyword">if</span> i &gt;= k - <span class="hljs-number">1</span>:<br>                <span class="hljs-comment"># 由于队首到队尾单调递减，所以窗口最大值就是队首</span><br>                res.append(nums[queue[<span class="hljs-number">0</span>]])<br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure>
<h3 id="347-前-k个高频元素">347. 前 k个高频元素</h3>
<ol>
<li>要统计元素出现频率</li>
<li>对频率排序</li>
<li>找出前 K 个高频元素</li>
</ol>
<p>首先统计元素出现的频率，这一类的问题可以使用 map 来进行统计。</p>
<p>然后是对频率进行排序，可以使用一种容器适配器就是<strong>优先级队列</strong>。</p>
<p>使用小顶堆，因为要统计最大前 k 个元素，只有小顶堆每次将最小的元素弹出，最后小顶堆里积累的才是前 k 个最大元素。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">topKFrequent</span>(<span class="hljs-params">self, nums, k</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type nums: List[int]</span><br><span class="hljs-string">        :type k: int</span><br><span class="hljs-string">        :rtype: List[int]</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-comment"># 使用字典统计频率</span><br>        dictionary = collections.Counter(nums)<br>        heap, res = [],[]<br>        <br>        <span class="hljs-comment"># 使用堆存储频率的负数来实现最大堆</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> dictionary:<br>            heapq.heappush(heap, (-dictionary[i], i))<br>            <br>        <span class="hljs-comment"># 提取前 k 个频率最高的元素</span><br>        <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(k):<br>            res.append(heapq.heappop(heap)[<span class="hljs-number">1</span>])<br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure>
<h2 id="二叉树">二叉树</h2>
<ol>
<li><strong>确定递归函数的参数和返回值</strong>：确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数，并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。</li>
<li><strong>确定终止条件</strong>：写完了递归算法，运行时经常遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。</li>
<li><strong>确定单层递归的逻辑</strong>：确定每一层递归需要处理的信息。</li>
</ol>
<h3 id="144-二叉树的前序遍历">144. 二叉树的前序遍历</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Definition for a binary tree node.</span><br><span class="hljs-comment"># class TreeNode(object):</span><br><span class="hljs-comment">#     def __init__(self, val=0, left=None, right=None):</span><br><span class="hljs-comment">#         self.val = val</span><br><span class="hljs-comment">#         self.left = left</span><br><span class="hljs-comment">#         self.right = right</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">preorderTraversal</span>(<span class="hljs-params">self, root</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type root: Optional[TreeNode]</span><br><span class="hljs-string">        :rtype: List[int]</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        res = []<br><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">node</span>):<br>            <span class="hljs-keyword">if</span> node <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                <span class="hljs-keyword">return</span><br><br>            res.append(node.val)<br>            dfs(node.left)<br>            dfs(node.right)<br><br>        dfs(root)<br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure>
<h3 id="145-二叉树的后序遍历">145. 二叉树的后序遍历</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Definition for a binary tree node.</span><br><span class="hljs-comment"># class TreeNode(object):</span><br><span class="hljs-comment">#     def __init__(self, val=0, left=None, right=None):</span><br><span class="hljs-comment">#         self.val = val</span><br><span class="hljs-comment">#         self.left = left</span><br><span class="hljs-comment">#         self.right = right</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">postorderTraversal</span>(<span class="hljs-params">self, root</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type root: Optional[TreeNode]</span><br><span class="hljs-string">        :rtype: List[int]</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        res = []<br><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">node</span>):<br>            <span class="hljs-keyword">if</span> node <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                <span class="hljs-keyword">return</span><br><br>            dfs(node.left)<br>            dfs(node.right)<br>            res.append(node.val)<br><br>        dfs(root)<br>        <span class="hljs-keyword">return</span> res        <br></code></pre></td></tr></table></figure>
<h3 id="94-二叉树的中序遍历">94. 二叉树的中序遍历</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Definition for a binary tree node.</span><br><span class="hljs-comment"># class TreeNode(object):</span><br><span class="hljs-comment">#     def __init__(self, val=0, left=None, right=None):</span><br><span class="hljs-comment">#         self.val = val</span><br><span class="hljs-comment">#         self.left = left</span><br><span class="hljs-comment">#         self.right = right</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">inorderTraversal</span>(<span class="hljs-params">self, root</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type root: Optional[TreeNode]</span><br><span class="hljs-string">        :rtype: List[int]</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        res = []<br><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">node</span>):<br>            <span class="hljs-keyword">if</span> node <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                <span class="hljs-keyword">return</span><br><br>            dfs(node.left)<br>            res.append(node.val)<br>            dfs(node.right)<br><br>        dfs(root)<br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure>
<h3 id="144-前序遍历（迭代遍历）">144. 前序遍历（迭代遍历）</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Definition for a binary tree node.</span><br><span class="hljs-comment"># class TreeNode(object):</span><br><span class="hljs-comment">#     def __init__(self, val=0, left=None, right=None):</span><br><span class="hljs-comment">#         self.val = val</span><br><span class="hljs-comment">#         self.left = left</span><br><span class="hljs-comment">#         self.right = right</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">preorderTraversal</span>(<span class="hljs-params">self, root</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type root: Optional[TreeNode]</span><br><span class="hljs-string">        :rtype: List[int]</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-comment"># 根节点为空则返回空列表</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:<br>            <span class="hljs-keyword">return</span> []<br><br>        stack = [root]<br>        res = []<br><br>        <span class="hljs-keyword">while</span> stack:<br>            node = stack.pop()<br>            <span class="hljs-comment"># 中结点先处理</span><br>            res.append(node.val)<br>            <span class="hljs-comment"># 右孩子先入栈</span><br>            <span class="hljs-keyword">if</span> node.right:<br>                stack.append(node.right)<br>            <span class="hljs-comment"># 左孩子后入栈</span><br>            <span class="hljs-keyword">if</span> node.left:<br>                stack.append(node.left)<br>        <span class="hljs-keyword">return</span> res <br></code></pre></td></tr></table></figure>
<h3 id="145-后序遍历（迭代遍历）">145. 后序遍历（迭代遍历）</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Definition for a binary tree node.</span><br><span class="hljs-comment"># class TreeNode(object):</span><br><span class="hljs-comment">#     def __init__(self, val=0, left=None, right=None):</span><br><span class="hljs-comment">#         self.val = val</span><br><span class="hljs-comment">#         self.left = left</span><br><span class="hljs-comment">#         self.right = right</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">postorderTraversal</span>(<span class="hljs-params">self, root</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type root: Optional[TreeNode]</span><br><span class="hljs-string">        :rtype: List[int]</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-comment"># 根节点为空则返回空列表</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:<br>            <span class="hljs-keyword">return</span> []<br><br>        stack = [root]<br>        res = []<br>        <br>        <span class="hljs-keyword">while</span> stack:<br>            node = stack.pop()<br>            <span class="hljs-comment"># 中结点先处理</span><br>            res.append(node.val)<br>            <span class="hljs-comment"># 左孩子先入栈</span><br>            <span class="hljs-keyword">if</span> node.left:<br>               stack.append(node.left)<br>            <span class="hljs-comment"># 右孩子后入栈</span><br>            <span class="hljs-keyword">if</span> node.right:<br>               stack.append(node.right)<br>        <span class="hljs-comment"># 将最终的数组翻转</span><br>        <span class="hljs-keyword">return</span> res[::-<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure>
<h3 id="102-二叉树的层序遍历">102. 二叉树的层序遍历</h3>
<p>需要借用一个辅助数据结构即队列来实现，队列先进先出，符合一层一层遍历的逻辑，而用栈先进后出适合模拟深度优先遍历也就是递归的逻辑。</p>
<p>而这种层序遍历方式就是图论中的广度优先遍历，只不过应用在二叉树上。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Definition for a binary tree node.</span><br><span class="hljs-comment"># class TreeNode(object):</span><br><span class="hljs-comment">#     def __init__(self, val=0, left=None, right=None):</span><br><span class="hljs-comment">#         self.val = val</span><br><span class="hljs-comment">#         self.left = left</span><br><span class="hljs-comment">#         self.right = right</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">levelOrder</span>(<span class="hljs-params">self, root</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type root: Optional[TreeNode]</span><br><span class="hljs-string">        :rtype: List[List[int]]</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:<br>            <span class="hljs-keyword">return</span> []<br><br>        queue = [root]<br>        res = []<br>        <span class="hljs-keyword">while</span> queue:<br>            level = []<br>            <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(queue)):<br>                cur = queue.pop(<span class="hljs-number">0</span>)<br>                level.append(cur.val)<br>                <span class="hljs-keyword">if</span> cur.left:<br>                    queue.append(cur.left)<br>                <span class="hljs-keyword">if</span> cur.right:<br>                    queue.append(cur.right)<br>            res.append(level)<br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure>
<h3 id="226-翻转二叉树">226. 翻转二叉树</h3>
<p>只要把每一个节点的左右孩子翻转一下，就可以达到整体翻转的效果。</p>
<p>使用前序遍历和后序遍历都可以，唯独中序遍历不方便，因为中序遍历会把某些节点的左右孩子翻转两次。</p>
<h4 id="递归法实现">递归法实现</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Definition for a binary tree node.</span><br><span class="hljs-comment"># class TreeNode(object):</span><br><span class="hljs-comment">#     def __init__(self, val=0, left=None, right=None):</span><br><span class="hljs-comment">#         self.val = val</span><br><span class="hljs-comment">#         self.left = left</span><br><span class="hljs-comment">#         self.right = right</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">invertTree</span>(<span class="hljs-params">self, root</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type root: Optional[TreeNode]</span><br><span class="hljs-string">        :rtype: Optional[TreeNode]</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-comment"># 递归函数的终止条件，节点为空时返回</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:<br>            <span class="hljs-keyword">return</span> <br>        <br>        <span class="hljs-comment"># 将当前节点的左右子树交换</span><br>        root.left, root.right = root.right, root.left<br>        <span class="hljs-comment"># 递归交换当前节点的 左子树和右子树</span><br>        self.invertTree(root.left)<br>        self.invertTree(root.right)<br>        <span class="hljs-keyword">return</span> root<br></code></pre></td></tr></table></figure>
<h4 id="迭代法实现">迭代法实现</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Definition for a binary tree node.</span><br><span class="hljs-comment"># class TreeNode(object):</span><br><span class="hljs-comment">#     def __init__(self, val=0, left=None, right=None):</span><br><span class="hljs-comment">#         self.val = val</span><br><span class="hljs-comment">#         self.left = left</span><br><span class="hljs-comment">#         self.right = right</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">invertTree</span>(<span class="hljs-params">self, root</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type root: Optional[TreeNode]</span><br><span class="hljs-string">        :rtype: Optional[TreeNode]</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:<br>            <span class="hljs-keyword">return</span> <br>        <span class="hljs-comment"># 将二叉树中的节点逐层放入栈中，再迭代处理队列中的元素</span><br>        stack = [root]<br>        <span class="hljs-keyword">while</span> stack:<br>            <span class="hljs-comment"># 每次都从栈中拿一个节点，并交换这个节点的左右子树</span><br>            node = stack.pop(<span class="hljs-number">0</span>)<br>            node.left, node.right = node.right, node.left<br>            <span class="hljs-keyword">if</span> node.left:<br>                stack.append(node.left)<br>            <span class="hljs-keyword">if</span> node.right:<br>                stack.append(node.right)<br>        <span class="hljs-keyword">return</span> root<br></code></pre></td></tr></table></figure>
<h3 id="101-对称二叉树">101. 对称二叉树</h3>
<p>判断对称二叉树要比较的是哪两个节点，不是左右节点。</p>
<p>对于二叉树是否对称，要比较的是根节点的左子树与右子树是不是相互翻转的。</p>
<p>将根节点的左子树记做 left，右子树记做 right。比较 left 是否等于 right，不等的话直接返回就可以了。</p>
<p>如果相当，比较 left 的左节点和 right 的右节点，再比较 left 的右节点和 right 的左节点。</p>
<h4 id="递归法">递归法</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Definition for a binary tree node.</span><br><span class="hljs-comment"># class TreeNode(object):</span><br><span class="hljs-comment">#     def __init__(self, val=0, left=None, right=None):</span><br><span class="hljs-comment">#         self.val = val</span><br><span class="hljs-comment">#         self.left = left</span><br><span class="hljs-comment">#         self.right = right</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">isSymmetric</span>(<span class="hljs-params">self, root</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type root: Optional[TreeNode]</span><br><span class="hljs-string">        :rtype: bool</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:<br>            <span class="hljs-keyword">return</span><br>        <br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">left, right</span>):<br>            <span class="hljs-comment"># 递归的终止条件是两个节点都为空</span><br>			<span class="hljs-comment"># 或者两个节点中有一个为空</span><br>			<span class="hljs-comment"># 或者两个节点的值不相等</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span>(left <span class="hljs-keyword">or</span> right):<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span>(left <span class="hljs-keyword">and</span> right):<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>            <span class="hljs-keyword">if</span> left.val != right.val:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>            <span class="hljs-keyword">return</span> dfs(left.left, right.right) <span class="hljs-keyword">and</span> dfs(left.right, right.left)<br>        <span class="hljs-keyword">return</span> dfs(root.left, root.right)<br></code></pre></td></tr></table></figure>
<h4 id="迭代法">迭代法</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Definition for a binary tree node.</span><br><span class="hljs-comment"># class TreeNode(object):</span><br><span class="hljs-comment">#     def __init__(self, val=0, left=None, right=None):</span><br><span class="hljs-comment">#         self.val = val</span><br><span class="hljs-comment">#         self.left = left</span><br><span class="hljs-comment">#         self.right = right</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">isSymmetric</span>(<span class="hljs-params">self, root</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type root: Optional[TreeNode]</span><br><span class="hljs-string">        :rtype: bool</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:<br>            <span class="hljs-keyword">return</span> <br>        <br>        stack = [root.left, root.right]<br>        <span class="hljs-keyword">while</span> stack:<br>            <span class="hljs-comment"># 从栈中取出两个节点，再比较这两个节点</span><br>            left = stack.pop(<span class="hljs-number">0</span>)<br>            right = stack.pop(<span class="hljs-number">0</span>)<br>            <span class="hljs-comment"># 如果两个节点都为空就继续循环，两者有一个为空就返回false</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span>(left <span class="hljs-keyword">or</span> right):<br>                <span class="hljs-keyword">continue</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span>(left <span class="hljs-keyword">and</span> right):<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>            <span class="hljs-keyword">if</span> left.val != right.val:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>            <span class="hljs-comment"># 将左节点的左孩子， 右节点的右孩子放入栈</span><br>            stack.append(left.left)<br>            stack.append(right.right)<br>            <span class="hljs-comment"># 将左节点的右孩子，右节点的左孩子放入栈</span><br>            stack.append(left.right)<br>            stack.append(right.left)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure>
<h3 id="104-二叉树的最大深度">104. 二叉树的最大深度</h3>
<p>可以使用前序（中左右），也可以使用后序遍历（左右中），使用前序求的就是深度，使用后序求的是高度。</p>
<ul>
<li>二叉树节点的深度：指从根节点到该节点的最长简单路径边的条数或者节点数（取决于深度从 0 开始还是从 1 开始）</li>
<li>二叉树节点的高度：指从该节点到叶子节点的最长简单路径边的条数或者节点数（取决于高度从 0 开始还是从 1 开始）</li>
</ul>
<p>而根节点的高度就是二叉树的最大深度。</p>
<h4 id="递归法-2">递归法</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Definition for a binary tree node.</span><br><span class="hljs-comment"># class TreeNode(object):</span><br><span class="hljs-comment">#     def __init__(self, val=0, left=None, right=None):</span><br><span class="hljs-comment">#         self.val = val</span><br><span class="hljs-comment">#         self.left = left</span><br><span class="hljs-comment">#         self.right = right</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">maxDepth</span>(<span class="hljs-params">self, root</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type root: Optional[TreeNode]</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">return</span> self.getDepth(root)<br>        <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">getDepth</span>(<span class="hljs-params">self, node</span>):<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> node:<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>            <span class="hljs-comment"># 左</span><br>            leftHeight = self.getDepth(node.left)<br>            <span class="hljs-comment"># 右</span><br>            rightHeight = self.getDepth(node.right)<br>            <span class="hljs-comment"># 中</span><br>            height = <span class="hljs-number">1</span> + <span class="hljs-built_in">max</span>(leftHeight, rightHeight)<br>            <span class="hljs-keyword">return</span> height<br></code></pre></td></tr></table></figure>
<h4 id="迭代法-2">迭代法</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Definition for a binary tree node.</span><br><span class="hljs-comment"># class TreeNode(object):</span><br><span class="hljs-comment">#     def __init__(self, val=0, left=None, right=None):</span><br><span class="hljs-comment">#         self.val = val</span><br><span class="hljs-comment">#         self.left = left</span><br><span class="hljs-comment">#         self.right = right</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">maxDepth</span>(<span class="hljs-params">self, root</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type root: Optional[TreeNode]</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        <br>        depth = <span class="hljs-number">0</span><br>        queue = [root]<br><br>        <span class="hljs-keyword">while</span> queue:<br>            depth += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(queue)):<br>                node = queue.pop(<span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">if</span> node.left:<br>                    queue.append(node.left)<br>                <span class="hljs-keyword">if</span> node.right:<br>                    queue.append(node.right)<br>        <span class="hljs-keyword">return</span> depth<br></code></pre></td></tr></table></figure>
<h3 id="111-二叉树的最小深度">111. 二叉树的最小深度</h3>
<h4 id="递归法-3">递归法</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Definition for a binary tree node.</span><br><span class="hljs-comment"># class TreeNode(object):</span><br><span class="hljs-comment">#     def __init__(self, val=0, left=None, right=None):</span><br><span class="hljs-comment">#         self.val = val</span><br><span class="hljs-comment">#         self.left = left</span><br><span class="hljs-comment">#         self.right = right</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minDepth</span>(<span class="hljs-params">self, root</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type root: Optional[TreeNode]</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">return</span> self.getDepth(root)<br>        <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">getDepth</span>(<span class="hljs-params">self, node</span>):<br>        <span class="hljs-keyword">if</span> node <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        leftDepth = self.getDepth(node.left)<br>        rightDepth = self.getDepth(node.right)<br><br>        <span class="hljs-comment"># 当一个左子树为空，右不为空，这时并不是最低点</span><br>        <span class="hljs-keyword">if</span> node.left <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> node.right <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + rightDepth<br>        <br>        <span class="hljs-comment"># 当一个右子树为空，左不为空，这时并不是最低点</span><br>        <span class="hljs-keyword">if</span> node.left <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> node.right <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + leftDepth<br><br>        height = <span class="hljs-number">1</span> + <span class="hljs-built_in">min</span>(leftDepth, rightDepth)<br>        <span class="hljs-keyword">return</span> height<br></code></pre></td></tr></table></figure>
<h4 id="迭代法-3">迭代法</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Definition for a binary tree node.</span><br><span class="hljs-comment"># class TreeNode(object):</span><br><span class="hljs-comment">#     def __init__(self, val=0, left=None, right=None):</span><br><span class="hljs-comment">#         self.val = val</span><br><span class="hljs-comment">#         self.left = left</span><br><span class="hljs-comment">#         self.right = right</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minDepth</span>(<span class="hljs-params">self, root</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type root: Optional[TreeNode]</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br><br>        depth = <span class="hljs-number">0</span><br>        queue = [root]<br><br>        <span class="hljs-keyword">while</span> queue:<br>            depth += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(queue)):<br>                node = queue.pop(<span class="hljs-number">0</span>)<br><br>                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> node.left <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> node.right:<br>                    <span class="hljs-keyword">return</span> depth<br><br>                <span class="hljs-keyword">if</span> node.left:<br>                    queue.append(node.left)<br><br>                <span class="hljs-keyword">if</span> node.right:<br>                    queue.append(node.right)<br><br>        <span class="hljs-keyword">return</span> depth<br></code></pre></td></tr></table></figure>
<h3 id="110-平衡二叉树">110. 平衡二叉树</h3>
<p>概念：</p>
<ul>
<li>二叉树节点的深度：指从根节点到该节点的最长简单路径边的条数。</li>
<li>二叉树节点的高度：指从该节点到叶子节点的最长简单路径边的条数。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Definition for a binary tree node.</span><br><span class="hljs-comment"># class TreeNode(object):</span><br><span class="hljs-comment">#     def __init__(self, val=0, left=None, right=None):</span><br><span class="hljs-comment">#         self.val = val</span><br><span class="hljs-comment">#         self.left = left</span><br><span class="hljs-comment">#         self.right = right</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">isBalanced</span>(<span class="hljs-params">self, root</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type root: Optional[TreeNode]</span><br><span class="hljs-string">        :rtype: bool</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>        <span class="hljs-comment"># 检查当前节点的左右子树高度差是否小于 2。</span><br>        <span class="hljs-comment"># 确保左右子树本身也是平衡的。</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">abs</span>(self.height(root.right) - self.height(root.left)) &lt; <span class="hljs-number">2</span> <span class="hljs-keyword">and</span> self.isBalanced(root.left) <span class="hljs-keyword">and</span> self.isBalanced(root.right)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">height</span>(<span class="hljs-params">self, node</span>):<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> node:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + <span class="hljs-built_in">max</span>(self.height(node.right), self.height(node.left))<br></code></pre></td></tr></table></figure>
<h3 id="257-二叉树的所有路径">257. 二叉树的所有路径</h3>
<p>要求从根节点到叶子的路径，所以需要前序遍历，方便让父节点指向孩子节点，找到对应的路径。</p>
<p>这道题目涉及到回溯，因为要把路径记录下来，需要回溯来回退一个路径再进入另一个路径。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Definition for a binary tree node.</span><br><span class="hljs-comment"># class TreeNode(object):</span><br><span class="hljs-comment">#     def __init__(self, val=0, left=None, right=None):</span><br><span class="hljs-comment">#         self.val = val</span><br><span class="hljs-comment">#         self.left = left</span><br><span class="hljs-comment">#         self.right = right</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">binaryTreePaths</span>(<span class="hljs-params">self, root</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type root: Optional[TreeNode]</span><br><span class="hljs-string">        :rtype: List[str]</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        res = []<br>        path = []<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:<br>            <span class="hljs-keyword">return</span> res<br>        self.traversal(root, path, res)<br>        <span class="hljs-keyword">return</span> res<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">traversal</span>(<span class="hljs-params">self, temp, path, res</span>):<br>        path.append(temp.val) <span class="hljs-comment"># 中</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> temp.left <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> temp.right: <span class="hljs-comment"># 到达叶子节点</span><br>            sPath = <span class="hljs-string">&#x27;-&gt;&#x27;</span>.join(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">str</span>, path))<br>            res.append(sPath)<br>            <span class="hljs-keyword">return</span><br>        <span class="hljs-keyword">if</span> temp.left: <span class="hljs-comment"># 左</span><br>            self.traversal(temp.left, path, res)<br>            path.pop() <span class="hljs-comment"># 回溯</span><br>        <span class="hljs-keyword">if</span> temp.right: <span class="hljs-comment"># 右</span><br>            self.traversal(temp.right, path, res)<br>            path.pop() <span class="hljs-comment"># 回溯</span><br></code></pre></td></tr></table></figure>
<h3 id="404-左叶子之和">404. 左叶子之和</h3>
<p>首先要注意是判断左叶子，不是二叉树左侧节点。</p>
<p>左叶子的明确定义：节点 A 的左孩子不为空，且左孩子的左右孩子都为空（说明是叶子节点），那么 A 节点的左孩子为左叶子节点。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Definition for a binary tree node.</span><br><span class="hljs-comment"># class TreeNode(object):</span><br><span class="hljs-comment">#     def __init__(self, val=0, left=None, right=None):</span><br><span class="hljs-comment">#         self.val = val</span><br><span class="hljs-comment">#         self.left = left</span><br><span class="hljs-comment">#         self.right = right</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">sumOfLeftLeaves</span>(<span class="hljs-params">self, root</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type root: Optional[TreeNode]</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> root <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        <span class="hljs-keyword">if</span> root.left <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> root.right <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br><br>        leftValue = self.sumOfLeftLeaves(root.left) <span class="hljs-comment"># 左</span><br>        <span class="hljs-keyword">if</span> root.left <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> root.left.left <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> root.left.right:  <span class="hljs-comment"># 左子树是左叶子的情况</span><br>            leftValue = root.left.val<br><br>        rightValue = self.sumOfLeftLeaves(root.right) <span class="hljs-comment"># 右</span><br><br>        sumValue = leftValue + rightValue <span class="hljs-comment"># 中</span><br>        <span class="hljs-keyword">return</span> sumValue <br></code></pre></td></tr></table></figure>
<h3 id="222-完全二叉树的节点个数">222. 完全二叉树的节点个数</h3>
<p>在完全二叉树中，除了最底层节点可能没填满，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~2^(h-1) 个节点。</p>
<h4 id="递归">递归</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Definition for a binary tree node.</span><br><span class="hljs-comment"># class TreeNode(object):</span><br><span class="hljs-comment">#     def __init__(self, val=0, left=None, right=None):</span><br><span class="hljs-comment">#         self.val = val</span><br><span class="hljs-comment">#         self.left = left</span><br><span class="hljs-comment">#         self.right = right</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">countNodes</span>(<span class="hljs-params">self, root</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type root: Optional[TreeNode]</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">return</span> self.getNodesNum(root)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">getNodesNum</span>(<span class="hljs-params">self, temp</span>):<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> temp:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        leftNum = self.getNodesNum(temp.left) <span class="hljs-comment"># 左</span><br>        rightNum = self.getNodesNum(temp.right) <span class="hljs-comment"># 右</span><br>        treeNum = leftNum + rightNum + <span class="hljs-number">1</span> <span class="hljs-comment"># 中</span><br>        <span class="hljs-keyword">return</span> treeNum<br></code></pre></td></tr></table></figure>
<h4 id="完全二叉树写法">完全二叉树写法</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Definition for a binary tree node.</span><br><span class="hljs-comment"># class TreeNode(object):</span><br><span class="hljs-comment">#     def __init__(self, val=0, left=None, right=None):</span><br><span class="hljs-comment">#         self.val = val</span><br><span class="hljs-comment">#         self.left = left</span><br><span class="hljs-comment">#         self.right = right</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">countNodes</span>(<span class="hljs-params">self, root</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type root: Optional[TreeNode]</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        left = root.left<br>        right = root.right<br>        leftDepth = <span class="hljs-number">0</span><br>        rightDepth = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> left: <span class="hljs-comment"># 求左子树深度</span><br>            left = left.left<br>            leftDepth += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">while</span> right: <span class="hljs-comment"># 求右子树深度</span><br>            right = right.right<br>            rightDepth += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">if</span> leftDepth == rightDepth:<br>            <span class="hljs-comment"># 这一步利用了满二叉树的性质：一个深度为 d 的满二叉树有 2^(d+1) - 1 个节点</span><br>            <span class="hljs-keyword">return</span> (<span class="hljs-number">2</span> &lt;&lt; leftDepth) - <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> self.countNodes(root.left) + self.countNodes(root.right) + <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>
<h3 id="513-找树左下角的值">513. 找树左下角的值</h3>
<p>采用递归方法实现：</p>
<ol>
<li>确定递归函数的参数和返回值
<ul>
<li>参数必须有要遍历的树的根节点</li>
</ul>
</li>
<li>确定终止条件
<ul>
<li>当遇到叶子节点的时候，就需要统计一下最大的深度了，所以需要遇到叶子节点来更新最大深度</li>
</ul>
</li>
<li>确定单层递归的逻辑
<ul>
<li>在找最大深度的时候，递归的过程中依然要使用回溯</li>
</ul>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Definition for a binary tree node.</span><br><span class="hljs-comment"># class TreeNode(object):</span><br><span class="hljs-comment">#     def __init__(self, val=0, left=None, right=None):</span><br><span class="hljs-comment">#         self.val = val</span><br><span class="hljs-comment">#         self.left = left</span><br><span class="hljs-comment">#         self.right = right</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">findBottomLeftValue</span>(<span class="hljs-params">self, root</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type root: Optional[TreeNode]</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        queue = deque()<br>        queue.append(root)<br>        res = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> queue:<br>            size = <span class="hljs-built_in">len</span>(queue)<br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(size):<br>                node = queue.popleft()<br>                <span class="hljs-keyword">if</span> i == <span class="hljs-number">0</span>:<br>                    res = node.val<br>                <span class="hljs-keyword">if</span> node.left:<br>                    queue.append(node.left)<br>                <span class="hljs-keyword">if</span> node.right:<br>                    queue.append(node.right)<br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure>
<h3 id="112-路径总和">112. 路径总和</h3>
<p>可以使用深度优先遍历的方式来遍历二叉树</p>
<p>递归函数什么时候需要返回值？</p>
<ul>
<li>如果需要搜索整棵二叉树且不用处理递归返回值，递归函数就不要返回值。</li>
<li>如果需要搜索整棵二叉树且需要处理递归返回值，递归函数就需要返回值。</li>
<li>如果要搜索其中一条符合条件的路径，那么递归一定需要返回值，因为遇到符合条件的路径就要及时返回。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Definition for a binary tree node.</span><br><span class="hljs-comment"># class TreeNode(object):</span><br><span class="hljs-comment">#     def __init__(self, val=0, left=None, right=None):</span><br><span class="hljs-comment">#         self.val = val</span><br><span class="hljs-comment">#         self.left = left</span><br><span class="hljs-comment">#         self.right = right</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">hasPathSum</span>(<span class="hljs-params">self, root, targetSum</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type root: Optional[TreeNode]</span><br><span class="hljs-string">        :type targetSum: int</span><br><span class="hljs-string">        :rtype: bool</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br>        <span class="hljs-comment"># 如果当前节点为叶子节点，且叶子节点的值等于减去该路径之前节点的值，返回 True</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root.left <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> root.right <span class="hljs-keyword">and</span> root.val == targetSum:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>        <br>        <span class="hljs-comment"># 递归左子树</span><br>        leftPath = self.hasPathSum(root.left, targetSum - root.val)<br>        <span class="hljs-comment"># 递归右子树</span><br>        rightPath = self.hasPathSum(root.right, targetSum - root.val)<br><br>        <span class="hljs-keyword">return</span> leftPath <span class="hljs-keyword">or</span> rightPath<br></code></pre></td></tr></table></figure>
<h3 id="106-从中序与后序遍历序列构造二叉树">106. 从中序与后序遍历序列构造二叉树</h3>
<p>一层一层切割，应该想到递归。</p>
<ul>
<li>第一步：如果数组大小为零的话，说明是空节点了。</li>
<li>第二步：如果不为空，那么取后序数组最后一个元素作为节点元素。</li>
<li>第三步：找到后序数组最后一个元素在中序数组的位置，作为切割点</li>
<li>第四步：切割中序数组，切成中序左数组和中序右数组 （顺序别搞反了，一定是先切中序数组）</li>
<li>第五步：切割后序数组，切成后序左数组和后序右数组</li>
<li>第六步：递归处理左区间和右区间</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Definition for a binary tree node.</span><br><span class="hljs-comment"># class TreeNode(object):</span><br><span class="hljs-comment">#     def __init__(self, val=0, left=None, right=None):</span><br><span class="hljs-comment">#         self.val = val</span><br><span class="hljs-comment">#         self.left = left</span><br><span class="hljs-comment">#         self.right = right</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">buildTree</span>(<span class="hljs-params">self, inorder, postorder</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type inorder: List[int]</span><br><span class="hljs-string">        :type postorder: List[int]</span><br><span class="hljs-string">        :rtype: Optional[TreeNode]</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-comment"># 1. 数为空</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> postorder:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br><br>        <span class="hljs-comment"># 2. 后序遍历的最后一个就是当前的中间节点</span><br>        root_val = postorder[-<span class="hljs-number">1</span>]<br>        root = TreeNode(root_val)<br><br>        <span class="hljs-comment"># 3. 找切割点</span><br>        separator_idx = inorder.index(root_val)<br><br>        <span class="hljs-comment"># 4. 切割 inroder 数组</span><br>        inorder_left = inorder[:separator_idx]<br>        inorder_right = inorder[separator_idx + <span class="hljs-number">1</span>:]<br><br>        <span class="hljs-comment"># 5. 切割 postorder 数组</span><br>        <span class="hljs-comment"># 中序数组大小一定跟后序数组大小是相同的</span><br>        postorder_left = postorder[:<span class="hljs-built_in">len</span>(inorder_left)]<br>        postorder_right = postorder[<span class="hljs-built_in">len</span>(inorder_left): -<span class="hljs-number">1</span>]<br><br>        <span class="hljs-comment"># 6. 递归</span><br>        root.left = self.buildTree(inorder_left, postorder_left)<br>        root.right = self.buildTree(inorder_right, postorder_right)<br><br>        <span class="hljs-comment"># 7. 返回答案</span><br>        <span class="hljs-keyword">return</span> root<br></code></pre></td></tr></table></figure>
<h3 id="654-最大二叉树">654. 最大二叉树</h3>
<p>以此数组构建的最大二叉树定义如下：</p>
<ul>
<li>二叉树的根是数组中的最大元素</li>
<li>左子树是通过数组中最大值左边部分构造出的最大二叉树</li>
<li>右子树是通过数组中最大值右边部分构造出的最大二叉树</li>
</ul>
<p>构造树一般采用的是前序遍历，因为先构造中间节点，然后递归构造左子树和右子树。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Definition for a binary tree node.</span><br><span class="hljs-comment"># class TreeNode(object):</span><br><span class="hljs-comment">#     def __init__(self, val=0, left=None, right=None):</span><br><span class="hljs-comment">#         self.val = val</span><br><span class="hljs-comment">#         self.left = left</span><br><span class="hljs-comment">#         self.right = right</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">constructMaximumBinaryTree</span>(<span class="hljs-params">self, nums</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type nums: List[int]</span><br><span class="hljs-string">        :rtype: Optional[TreeNode]</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">return</span> TreeNode(nums[<span class="hljs-number">0</span>])<br>        node = TreeNode(<span class="hljs-number">0</span>)<br><br>        <span class="hljs-comment"># 找到数组中最大的值和对应的下标</span><br>        maxValue = <span class="hljs-number">0</span><br>        maxValueIndex = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums)):<br>            <span class="hljs-keyword">if</span> nums[i] &gt; maxValue:<br>                maxValue = nums[i]<br>                maxValueIndex = i<br>        node.val = maxValue<br><br>        <span class="hljs-comment"># 最大值所在的下标左区间 构造左子树</span><br>        <span class="hljs-keyword">if</span> maxValueIndex &gt; <span class="hljs-number">0</span>:<br>            new_list = nums[:maxValueIndex]<br>            node.left = self.constructMaximumBinaryTree(new_list)<br>        <span class="hljs-comment"># 最大值所在的下标右区间 构造右子树</span><br>        <span class="hljs-keyword">if</span> maxValueIndex &lt; <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span>:<br>            new_list = nums[maxValueIndex + <span class="hljs-number">1</span>:]<br>            node.right = self.constructMaximumBinaryTree(new_list)<br>        <span class="hljs-keyword">return</span> node<br></code></pre></td></tr></table></figure>
<h3 id="617-合并二叉树">617. 合并二叉树</h3>
<p>和遍历一个树逻辑一样，只不过传入两个树的节点，同时操作。</p>
<p>迭代法实现：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Definition for a binary tree node.</span><br><span class="hljs-comment"># class TreeNode(object):</span><br><span class="hljs-comment">#     def __init__(self, val=0, left=None, right=None):</span><br><span class="hljs-comment">#         self.val = val</span><br><span class="hljs-comment">#         self.left = left</span><br><span class="hljs-comment">#         self.right = right</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">mergeTrees</span>(<span class="hljs-params">self, root1, root2</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type root1: Optional[TreeNode]</span><br><span class="hljs-string">        :type root2: Optional[TreeNode]</span><br><span class="hljs-string">        :rtype: Optional[TreeNode]</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root1:<br>            <span class="hljs-keyword">return</span> root2<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root2:<br>            <span class="hljs-keyword">return</span> root1<br>        <br>        queue = deque()<br>        queue.append(root1)<br>        queue.append(root2)<br><br>        <span class="hljs-keyword">while</span> queue:<br>            node1 = queue.popleft()<br>            node2 = queue.popleft()<br><br>            <span class="hljs-comment"># 更新 queue</span><br>            <span class="hljs-comment"># 只有两个节点都有左节点时，再往 queue 里面放</span><br>            <span class="hljs-keyword">if</span> node1.left <span class="hljs-keyword">and</span> node2.left:<br>                queue.append(node1.left)<br>                queue.append(node2.left)<br>            <span class="hljs-comment"># 只有两个节点都有右节点时，再往 queue 里面放</span><br>            <span class="hljs-keyword">if</span> node1.right <span class="hljs-keyword">and</span> node2.right:<br>                queue.append(node1.right)<br>                queue.append(node2.right)<br>            <br>            <span class="hljs-comment"># 更新当前节点，同时改变当前节点的左右孩子</span><br>            node1.val += node2.val<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> node1.left <span class="hljs-keyword">and</span> node2.left:<br>                node1.left = node2.left<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> node1.right <span class="hljs-keyword">and</span> node2.right:<br>                node1.right = node2.right<br>        <span class="hljs-keyword">return</span> root1<br></code></pre></td></tr></table></figure>
<h3 id="700-二叉搜索树中的搜索">700. 二叉搜索树中的搜索</h3>
<p>二叉搜索树是一个有序树：</p>
<ul>
<li>若它的左子树不为空，则左子树上所有节点的值均小于它的根节点的值</li>
<li>若它的右子树不为空，则右子树上所有节点的值均大于它的根节点的值</li>
<li>它的左、右子树也分别为二叉搜索树</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Definition for a binary tree node.</span><br><span class="hljs-comment"># class TreeNode(object):</span><br><span class="hljs-comment">#     def __init__(self, val=0, left=None, right=None):</span><br><span class="hljs-comment">#         self.val = val</span><br><span class="hljs-comment">#         self.left = left</span><br><span class="hljs-comment">#         self.right = right</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">searchBST</span>(<span class="hljs-params">self, root, val</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type root: Optional[TreeNode]</span><br><span class="hljs-string">        :type val: int</span><br><span class="hljs-string">        :rtype: Optional[TreeNode]</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">while</span> root:<br>            <span class="hljs-keyword">if</span> val &lt; root.val:<br>                root = root.left<br>            <span class="hljs-keyword">elif</span> val &gt; root.val:<br>                root = root.right<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">return</span> root<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br></code></pre></td></tr></table></figure>
<h3 id="98-验证二叉搜索树">98. 验证二叉搜索树</h3>
<p>中序遍历下，输出的二叉搜索树节点的数值是有序序列。</p>
<p>迭代法实现：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Definition for a binary tree node.</span><br><span class="hljs-comment"># class TreeNode(object):</span><br><span class="hljs-comment">#     def __init__(self, val=0, left=None, right=None):</span><br><span class="hljs-comment">#         self.val = val</span><br><span class="hljs-comment">#         self.left = left</span><br><span class="hljs-comment">#         self.right = right</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">isValidBST</span>(<span class="hljs-params">self, root</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type root: Optional[TreeNode]</span><br><span class="hljs-string">        :rtype: bool</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        stack = []<br>        cur = root<br>        pre = <span class="hljs-literal">None</span> <span class="hljs-comment"># 记录前一个节点</span><br><br>        <span class="hljs-keyword">while</span> cur <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">or</span> <span class="hljs-built_in">len</span>(stack) &gt; <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">if</span> cur <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>                stack.append(cur)<br>                cur = cur.left <span class="hljs-comment"># 左</span><br>            <span class="hljs-keyword">else</span>:<br>                cur = stack.pop() <span class="hljs-comment"># 中</span><br>                <span class="hljs-keyword">if</span> pre <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> cur.val &lt;= pre.val:<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>                pre = cur <span class="hljs-comment"># 保存前一个访问的节点</span><br>                cur = cur.right <span class="hljs-comment"># 右</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure>
<h3 id="530-二叉搜索树的最小绝对差">530. 二叉搜索树的最小绝对差</h3>
<p>二叉搜索树是有序的。</p>
<p>想象成在一个有序数组上求最值，求差值。</p>
<ul>
<li><code>getMinimumDifference</code> 方法首先用中序遍历将 BST 的节点值存入 <code>res</code> 列表，这样列表 <code>res</code> 中的值是有序的。</li>
<li>然后计算 <code>res</code> 中相邻元素的最小绝对差，并返回该最小值。</li>
<li><code>inorderTraversal</code> 方法使用递归实现中序遍历，保证节点值按升序排列。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Definition for a binary tree node.</span><br><span class="hljs-comment"># class TreeNode(object):</span><br><span class="hljs-comment">#     def __init__(self, val=0, left=None, right=None):</span><br><span class="hljs-comment">#         self.val = val</span><br><span class="hljs-comment">#         self.left = left</span><br><span class="hljs-comment">#         self.right = right</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">getMinimumDifference</span>(<span class="hljs-params">self, root</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type root: Optional[TreeNode]</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        res = []<br>        minRes = <span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;inf&#x27;</span>)<br>        self.inorderTraversal(root, res)<br>        <span class="hljs-comment"># 求最小绝对差</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(res) - <span class="hljs-number">1</span>):<br>            minRes = <span class="hljs-built_in">min</span>(<span class="hljs-built_in">abs</span>(res[i] - res[i + <span class="hljs-number">1</span>]), minRes)<br><br>        <span class="hljs-keyword">return</span> minRes<br>        <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">inorderTraversal</span>(<span class="hljs-params">self, root, res</span>):<br>        <span class="hljs-keyword">if</span> root == <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">return</span><br>        self.inorderTraversal(root.left, res)<br>        res.append(root.val)<br>        self.inorderTraversal(root.right, res)<br></code></pre></td></tr></table></figure>
<h3 id="501-二叉搜索树中的众数">501. 二叉搜索树中的众数</h3>
<p>使用迭代法实现：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Definition for a binary tree node.</span><br><span class="hljs-comment"># class TreeNode(object):</span><br><span class="hljs-comment">#     def __init__(self, val=0, left=None, right=None):</span><br><span class="hljs-comment">#         self.val = val</span><br><span class="hljs-comment">#         self.left = left</span><br><span class="hljs-comment">#         self.right = right</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">findMode</span>(<span class="hljs-params">self, root</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type root: Optional[TreeNode]</span><br><span class="hljs-string">        :rtype: List[int]</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        stack = []<br>        <span class="hljs-comment"># 记录前一个元素</span><br>        pre = <span class="hljs-literal">None</span><br>        <span class="hljs-comment"># 记录次数</span><br>        count = <span class="hljs-number">0</span><br>        <span class="hljs-comment"># 记录最大次数</span><br>        maxCount = <span class="hljs-number">0</span><br>        <span class="hljs-comment"># 记录结果</span><br>        res = []<br><br>        <span class="hljs-keyword">while</span> root <span class="hljs-keyword">or</span> stack:<br>            <span class="hljs-keyword">if</span> root:<br>                stack.append(root)<br>                root = root.left<br>            <span class="hljs-keyword">else</span>:<br>                cur = stack.pop()<br>                <span class="hljs-comment"># 第一个节点</span><br>                <span class="hljs-keyword">if</span> pre == <span class="hljs-literal">None</span>:<br>                    count = <span class="hljs-number">1</span><br>                <span class="hljs-comment"># 如果与前一个节点的值相等</span><br>                <span class="hljs-keyword">elif</span> pre.val == cur.val:<br>                    count += <span class="hljs-number">1</span><br>                <span class="hljs-keyword">else</span>:<br>                    count = <span class="hljs-number">1</span><br><br>                <span class="hljs-comment"># 如果和最大次数相同，将值放入 res</span><br>                <span class="hljs-keyword">if</span> count == maxCount:<br>                    res.append(cur.val)<br>                <span class="hljs-comment"># 如果大于最大次数</span><br>                <span class="hljs-keyword">if</span> count &gt; maxCount:<br>                    maxCount = count<br>                    res = [cur.val]<br>                pre = cur<br>                root = cur.right<br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure>
<h3 id="236-二叉树的最近公共祖先">236. 二叉树的最近公共祖先</h3>
<p>首先想到自底向上查找，这样就可以找到公共祖先了。</p>
<p>二叉树回溯的过程就是自底向上。</p>
<p>后序遍历（左右中）就是天然的回溯过程，可以根据左右子树的返回值，来处理中节点的逻辑。</p>
<ul>
<li>求最小公共祖先，需要从底向上遍历，二叉树只能通过后序遍历实现从底向上的遍历方式。</li>
<li>在回溯的过程中，必然要遍历整颗二叉树，即使已经找到结果，依然要把其他节点遍历完，因为要使用递归函数的返回值（也就是代码中的 left 和 right）做逻辑判断。</li>
<li>如果返回值 left 为空，right 不为空返回 right，可以用返回 right 传给上一层结果。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Definition for a binary tree node.</span><br><span class="hljs-comment"># class TreeNode(object):</span><br><span class="hljs-comment">#     def __init__(self, x):</span><br><span class="hljs-comment">#         self.val = x</span><br><span class="hljs-comment">#         self.left = None</span><br><span class="hljs-comment">#         self.right = None</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">lowestCommonAncestor</span>(<span class="hljs-params">self, root, p, q</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type root: TreeNode</span><br><span class="hljs-string">        :type p: TreeNode</span><br><span class="hljs-string">        :type q: TreeNode</span><br><span class="hljs-string">        :rtype: TreeNode</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> root == p <span class="hljs-keyword">or</span> root == q <span class="hljs-keyword">or</span> root <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">return</span> root<br>        <br>        left = self.lowestCommonAncestor(root.left, p, q)<br>        right = self.lowestCommonAncestor(root.right, p, q)<br><br>        <span class="hljs-keyword">if</span> left <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> right <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">return</span> root<br>        <br>        <span class="hljs-keyword">if</span> left <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> right <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">return</span> right<br>        <span class="hljs-keyword">elif</span> left <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> right <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">return</span> left<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br></code></pre></td></tr></table></figure>
<h3 id="235-二叉搜索树的最近公共祖先">235. 二叉搜索树的最近公共祖先</h3>
<p>可以利用二叉搜索树有序的特点</p>
<p>使用迭代法实现：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Definition for a binary tree node.</span><br><span class="hljs-comment"># class TreeNode(object):</span><br><span class="hljs-comment">#     def __init__(self, x):</span><br><span class="hljs-comment">#         self.val = x</span><br><span class="hljs-comment">#         self.left = None</span><br><span class="hljs-comment">#         self.right = None</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">lowestCommonAncestor</span>(<span class="hljs-params">self, root, p, q</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type root: TreeNode</span><br><span class="hljs-string">        :type p: TreeNode</span><br><span class="hljs-string">        :type q: TreeNode</span><br><span class="hljs-string">        :rtype: TreeNode</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">while</span> root:<br>            <span class="hljs-keyword">if</span> root.val &gt; p.val <span class="hljs-keyword">and</span> root.val &gt; q.val:<br>                root = root.left<br>            <span class="hljs-keyword">elif</span> root.val &lt; p.val <span class="hljs-keyword">and</span> root.val &lt; q.val:<br>                root = root.right<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">return</span> root<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br></code></pre></td></tr></table></figure>
<h3 id="701-二叉搜索树中的插入操作">701. 二叉搜索树中的插入操作</h3>
<p>只要按照二叉搜索树的规则去遍历，遇到空节点就插入节点就可以了。</p>
<p>采用递归方法实现：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Definition for a binary tree node.</span><br><span class="hljs-comment"># class TreeNode(object):</span><br><span class="hljs-comment">#     def __init__(self, val=0, left=None, right=None):</span><br><span class="hljs-comment">#         self.val = val</span><br><span class="hljs-comment">#         self.left = left</span><br><span class="hljs-comment">#         self.right = right</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">insertIntoBST</span>(<span class="hljs-params">self, root, val</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type root: Optional[TreeNode]</span><br><span class="hljs-string">        :type val: int</span><br><span class="hljs-string">        :rtype: Optional[TreeNode]</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:<br>            node = TreeNode(val)<br>            <span class="hljs-keyword">return</span> node<br>        <br>        <span class="hljs-keyword">if</span> root.val &gt; val:<br>            root.left = self.insertIntoBST(root.left, val)<br>        <span class="hljs-keyword">if</span> root.val &lt; val:<br>            root.right = self.insertIntoBST(root.right, val)<br><br>        <span class="hljs-keyword">return</span> root<br></code></pre></td></tr></table></figure>
<h3 id="450-删除二叉搜索树中的节点">450. 删除二叉搜索树中的节点</h3>
<p>搜索树的节点删除要比节点增加复杂的多，有很多情况需要考虑。</p>
<ul>
<li>第一种情况：没找到删除的节点，遍历到空节点直接返回了。</li>
<li>找到删除的节点：
<ul>
<li>第二种情况：左右孩子都为空（叶子节点），直接删除节点，返回 NULL 为根节点。</li>
<li>第三种情况：删除节点的左孩子为空，右孩子不为空，删除节点，右孩子补位，返回右孩子为根节点。</li>
<li>第四种情况：删除节点的右孩子为空，左孩子不为空，删除节点，左孩子补位，返回左孩子为根节点。</li>
<li>第五种情况：左右孩子节点都不为空，则将删除节点的左子树头结点（左孩子）放到删除节点的右子树的最左面节点的左孩子上，返回删除节点右孩子为新的根节点。</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Definition for a binary tree node.</span><br><span class="hljs-comment"># class TreeNode(object):</span><br><span class="hljs-comment">#     def __init__(self, val=0, left=None, right=None):</span><br><span class="hljs-comment">#         self.val = val</span><br><span class="hljs-comment">#         self.left = left</span><br><span class="hljs-comment">#         self.right = right</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">deleteNode</span>(<span class="hljs-params">self, root, key</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type root: Optional[TreeNode]</span><br><span class="hljs-string">        :type key: int</span><br><span class="hljs-string">        :rtype: Optional[TreeNode]</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:<br>            <span class="hljs-keyword">return</span> root<br><br>        <span class="hljs-keyword">if</span> root.val == key:<br>            <span class="hljs-keyword">if</span> root.left <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> root.right <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>            <span class="hljs-keyword">elif</span> root.left <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                <span class="hljs-keyword">return</span> root.right<br>            <span class="hljs-keyword">elif</span> root.right <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                <span class="hljs-keyword">return</span> root.left<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-comment"># 临时存储</span><br>                cur = root.right<br>                <span class="hljs-keyword">while</span> cur.left <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>                    cur = cur.left<br>                cur.left = root.left<br>                <span class="hljs-keyword">return</span> root.right<br>        <br>        <span class="hljs-keyword">if</span> root.val &gt; key:<br>            root.left = self.deleteNode(root.left, key)<br>        <span class="hljs-keyword">if</span> root.val &lt; key:<br>            root.right = self.deleteNode(root.right, key)<br><br>        <span class="hljs-keyword">return</span> root<br></code></pre></td></tr></table></figure>
<h3 id="669-修剪二叉树">669. 修剪二叉树</h3>
<p>删除节点时，将删除节点的右孩子直接赋给父节点的左孩子就可以。</p>
<p>使用递归法实现</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Definition for a binary tree node.</span><br><span class="hljs-comment"># class TreeNode(object):</span><br><span class="hljs-comment">#     def __init__(self, val=0, left=None, right=None):</span><br><span class="hljs-comment">#         self.val = val</span><br><span class="hljs-comment">#         self.left = left</span><br><span class="hljs-comment">#         self.right = right</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">trimBST</span>(<span class="hljs-params">self, root, low, high</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type root: Optional[TreeNode]</span><br><span class="hljs-string">        :type low: int</span><br><span class="hljs-string">        :type high: int</span><br><span class="hljs-string">        :rtype: Optional[TreeNode]</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>        <span class="hljs-keyword">if</span> root.val &lt; low:<br>            <span class="hljs-comment"># 寻找符合区间 [low, high] 的节点</span><br>            <span class="hljs-keyword">return</span> self.trimBST(root.right, low, high)<br>        <span class="hljs-keyword">if</span> root.val &gt; high:<br>            <span class="hljs-comment"># 寻找符合区间 [low, high] 的节点</span><br>            <span class="hljs-keyword">return</span> self.trimBST(root.left, low, high)<br>        root.left = self.trimBST(root.left, low, high) <span class="hljs-comment"># root.left 接入符合条件的左孩子</span><br>        root.right = self.trimBST(root.right, low, high) <span class="hljs-comment"># root.right 接入符合条件的右孩子</span><br>        <span class="hljs-keyword">return</span> root<br></code></pre></td></tr></table></figure>
<h3 id="108-将有序数组转换为二叉搜索树">108. 将有序数组转换为二叉搜索树</h3>
<p>数组构造二叉树，构成平衡树时自然而然地事情，默认都是从数组中间位置取值作为节点元素。</p>
<p>本质就是寻找分割点，分割点作为当前节点，然后递归左区间和右区间。</p>
<p>如果数组长度为偶数，中间节点有两个，取哪一个都可以，只不过构成了不同的平衡二叉树。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Definition for a binary tree node.</span><br><span class="hljs-comment"># class TreeNode(object):</span><br><span class="hljs-comment">#     def __init__(self, val=0, left=None, right=None):</span><br><span class="hljs-comment">#         self.val = val</span><br><span class="hljs-comment">#         self.left = left</span><br><span class="hljs-comment">#         self.right = right</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">sortedArrayToBST</span>(<span class="hljs-params">self, nums</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type nums: List[int]</span><br><span class="hljs-string">        :rtype: Optional[TreeNode]</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        root = self.traversal(nums, <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> root<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">traversal</span>(<span class="hljs-params">self, nums, left, right</span>):<br>        <span class="hljs-keyword">if</span> left &gt; right:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br><br>        mid = left + (right - left) // <span class="hljs-number">2</span><br>        root = TreeNode(nums[mid])<br>        root.left = self.traversal(nums, left, mid - <span class="hljs-number">1</span>)<br>        root.right = self.traversal(nums, mid + <span class="hljs-number">1</span>, right)<br>        <span class="hljs-keyword">return</span> root<br></code></pre></td></tr></table></figure>
<h3 id="538-把二叉搜索树转换为累加树">538. 把二叉搜索树转换为累加树</h3>
<p>从树中可以看出累加的顺序是右中左，所以需要反中序遍历这个二叉树，然后顺序累加就可以了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Definition for a binary tree node.</span><br><span class="hljs-comment"># class TreeNode(object):</span><br><span class="hljs-comment">#     def __init__(self, val=0, left=None, right=None):</span><br><span class="hljs-comment">#         self.val = val</span><br><span class="hljs-comment">#         self.left = left</span><br><span class="hljs-comment">#         self.right = right</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">convertBST</span>(<span class="hljs-params">self, root</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type root: Optional[TreeNode]</span><br><span class="hljs-string">        :rtype: Optional[TreeNode]</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        self.pre = <span class="hljs-number">0</span>   <span class="hljs-comment"># 记录前一个节点的数值</span><br>        self.traversal(root)<br>        <span class="hljs-keyword">return</span> root<br>        <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">traversal</span>(<span class="hljs-params">self, cur</span>):<br>        <span class="hljs-keyword">if</span> cur <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">return</span><br><br>        self.traversal(cur.right)<br>        cur.val += self.pre<br>        self.pre = cur.val<br>        self.traversal(cur.left) <br></code></pre></td></tr></table></figure>
<h2 id="回溯算法">回溯算法</h2>
<p>回溯法也叫做回溯搜索法，是一种搜索方式。</p>
<p>回溯是递归的副产品，只要有递归就会有回溯。</p>
<p>回溯的本质是穷举，穷举所有可能，然后选出想要的答案，如果想让回溯法高效一些，可以加一些剪枝的操作，但也改不了回溯法就是穷举的本质。</p>
<p>回溯法一般可以解决如下几种问题：</p>
<ul>
<li>组合问题：N 个数里面按一定规则找出 k 个数的集合</li>
<li>切割问题：一个字符按一定规则有几种切割方式</li>
<li>子集问题：一个 N 个数的集合里有多少符合条件的子集</li>
<li>排列问题：N 个数按一定规则全排列，有几种排列方式</li>
<li>棋盘问题：N 皇后，解数独等等</li>
</ul>
<h3 id="77-组合">77. 组合</h3>
<p>未剪枝：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">combine</span>(<span class="hljs-params">self, n, k</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type n: int</span><br><span class="hljs-string">        :type k: int</span><br><span class="hljs-string">        :rtype: List[List[int]]</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        result = []  <span class="hljs-comment"># 存放结果集</span><br>        self.backtracking(n, k, <span class="hljs-number">1</span>, [], result)<br>        <span class="hljs-keyword">return</span> result<br>        <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">backtracking</span>(<span class="hljs-params">self, n, k, startIndex, path, result</span>):<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(path) == k:<br>            result.append(path[:])  <span class="hljs-comment"># 将当前的 path 添加到结果集</span><br>            <span class="hljs-keyword">return</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(startIndex, n + <span class="hljs-number">1</span>):<br>            path.append(i)  <span class="hljs-comment"># 处理节点</span><br>            self.backtracking(n, k, i + <span class="hljs-number">1</span>, path, result)<br>            path.pop()  <span class="hljs-comment"># 回溯，撤销处理的节点</span><br></code></pre></td></tr></table></figure>
<p>剪枝优化：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">combine</span>(<span class="hljs-params">self, n, k</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type n: int</span><br><span class="hljs-string">        :type k: int</span><br><span class="hljs-string">        :rtype: List[List[int]]</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        result = []  <span class="hljs-comment"># 存放结果集</span><br>        self.backtracking(n, k, <span class="hljs-number">1</span>, [], result)<br>        <span class="hljs-keyword">return</span> result<br>        <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">backtracking</span>(<span class="hljs-params">self, n, k, startIndex, path, result</span>):<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(path) == k:<br>            result.append(path[:])  <span class="hljs-comment"># 将当前的 path 添加到结果集</span><br>            <span class="hljs-keyword">return</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(startIndex, n - (k - <span class="hljs-built_in">len</span>(path)) + <span class="hljs-number">2</span>):  <span class="hljs-comment"># 剪枝优化</span><br>            path.append(i)  <span class="hljs-comment"># 处理节点</span><br>            self.backtracking(n, k, i + <span class="hljs-number">1</span>, path, result)<br>            path.pop()  <span class="hljs-comment"># 回溯，撤销处理的节点</span><br></code></pre></td></tr></table></figure>
<h3 id="216-组合总和Ⅲ">216. 组合总和Ⅲ</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">combinationSum3</span>(<span class="hljs-params">self, k, n</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type k: int</span><br><span class="hljs-string">        :type n: int</span><br><span class="hljs-string">        :rtype: List[List[int]]</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        result = []  <span class="hljs-comment"># 存放结果集</span><br>        self.backtracking(n, k, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, [], result)<br>        <span class="hljs-keyword">return</span> result<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">backtracking</span>(<span class="hljs-params">self, tragetSum, k, currentSum, startIndex, path, result</span>):<br>        <span class="hljs-keyword">if</span> currentSum &gt; tragetSum:  <span class="hljs-comment"># 剪枝操作</span><br>            <span class="hljs-keyword">return</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(path) == k:<br>            <span class="hljs-keyword">if</span> currentSum == tragetSum:<br>                result.append(path[:])<br>            <span class="hljs-keyword">return</span><br><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(startIndex, <span class="hljs-number">9</span> - (k - <span class="hljs-built_in">len</span>(path)) + <span class="hljs-number">2</span>):<br>            currentSum += i  <span class="hljs-comment"># 处理节点</span><br>            path.append(i)   <span class="hljs-comment"># 处理 </span><br>            self.backtracking(tragetSum, k, currentSum, i + <span class="hljs-number">1</span>, path, result)<br>            currentSum -= i  <span class="hljs-comment"># 回溯</span><br>            path.pop()  <span class="hljs-comment"># 回溯，撤销处理的节点</span><br></code></pre></td></tr></table></figure>
<h3 id="17-电话号码的字母组合">17. 电话号码的字母组合</h3>
<ol>
<li>数字与字母如何映射</li>
<li>两个字母就两个 for 循环，三个字母三个 for 循环，以此类推，无法写出代码</li>
<li>输入 1 * # 按键等异常情况</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        self.letterMap = [<br>            <span class="hljs-string">&quot;&quot;</span>,     <span class="hljs-comment"># 0</span><br>            <span class="hljs-string">&quot;&quot;</span>,     <span class="hljs-comment"># 1</span><br>            <span class="hljs-string">&quot;abc&quot;</span>,  <span class="hljs-comment"># 2</span><br>            <span class="hljs-string">&quot;def&quot;</span>,  <span class="hljs-comment"># 3</span><br>            <span class="hljs-string">&quot;ghi&quot;</span>,  <span class="hljs-comment"># 4</span><br>            <span class="hljs-string">&quot;jkl&quot;</span>,  <span class="hljs-comment"># 5</span><br>            <span class="hljs-string">&quot;mno&quot;</span>,  <span class="hljs-comment"># 6</span><br>            <span class="hljs-string">&quot;pqrs&quot;</span>, <span class="hljs-comment"># 7</span><br>            <span class="hljs-string">&quot;tuv&quot;</span>,  <span class="hljs-comment"># 8</span><br>            <span class="hljs-string">&quot;wxyz&quot;</span>  <span class="hljs-comment"># 9</span><br>        ]<br>        self.result = []<br>        self.s = <span class="hljs-string">&quot;&quot;</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">letterCombinations</span>(<span class="hljs-params">self, digits</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type digits: str</span><br><span class="hljs-string">        :rtype: List[str]</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(digits) == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> self.result<br>        self.backtracking(digits, <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> self.result<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">backtracking</span>(<span class="hljs-params">self, digits, index</span>):<br>        <span class="hljs-keyword">if</span> index == <span class="hljs-built_in">len</span>(digits):<br>            self.result.append(self.s)<br>            <span class="hljs-keyword">return</span><br>        digit = <span class="hljs-built_in">int</span>(digits[index])         <span class="hljs-comment"># 将索引处的数字转换为整数</span><br>        letters = self.letterMap[digit]   <span class="hljs-comment"># 获取对应的字符集</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(letters)):<br>            self.s += letters[i]           <span class="hljs-comment"># 处理字符</span><br>            self.backtracking(digits, index + <span class="hljs-number">1</span>)  <span class="hljs-comment"># 递归调用</span><br>            self.s = self.s[:-<span class="hljs-number">1</span>]           <span class="hljs-comment"># 回溯</span><br></code></pre></td></tr></table></figure>
<p>官方解法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">letterCombinations</span>(<span class="hljs-params">self, digits</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type digits: str</span><br><span class="hljs-string">        :rtype: List[str]</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-comment"># 边界条件</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> digits:<br>            <span class="hljs-keyword">return</span> []<br>        <br>        <span class="hljs-comment"># 一个映射表</span><br>        phoneMap = &#123;<br>            <span class="hljs-string">&quot;2&quot;</span>: <span class="hljs-string">&quot;abc&quot;</span>,<br>            <span class="hljs-string">&quot;3&quot;</span>: <span class="hljs-string">&quot;def&quot;</span>,<br>            <span class="hljs-string">&quot;4&quot;</span>: <span class="hljs-string">&quot;ghi&quot;</span>,<br>            <span class="hljs-string">&quot;5&quot;</span>: <span class="hljs-string">&quot;jkl&quot;</span>,<br>            <span class="hljs-string">&quot;6&quot;</span>: <span class="hljs-string">&quot;mno&quot;</span>,<br>            <span class="hljs-string">&quot;7&quot;</span>: <span class="hljs-string">&quot;pqrs&quot;</span>,<br>            <span class="hljs-string">&quot;8&quot;</span>: <span class="hljs-string">&quot;tuv&quot;</span>,<br>            <span class="hljs-string">&quot;9&quot;</span>: <span class="hljs-string">&quot;wxyz&quot;</span>,<br>        &#125;<br><br>        <span class="hljs-comment"># 回溯函数</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">backtrack</span>(<span class="hljs-params">index</span>):<br>            <span class="hljs-comment"># 递归结束条件</span><br>            <span class="hljs-keyword">if</span> index == <span class="hljs-built_in">len</span>(digits):<br>                combinations.append(<span class="hljs-string">&quot;&quot;</span>.join(combination))<br>            <span class="hljs-keyword">else</span>:<br>                digit = digits[index]<br>                <span class="hljs-keyword">for</span> letter <span class="hljs-keyword">in</span> phoneMap[digit]:<br>                    combination.append(letter)<br>                    backtrack(index + <span class="hljs-number">1</span>)<br>                    combination.pop()<br>            <br>        <span class="hljs-comment"># 初始化变量</span><br>        combination = <span class="hljs-built_in">list</span>()<br>        combinations = <span class="hljs-built_in">list</span>()<br>        backtrack(<span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> combinations<br></code></pre></td></tr></table></figure>
<h3 id="39-组合总和">39. 组合总和</h3>
<p>注意叶子结点的返回条件，本题没有组合要求，仅仅是总和的限制，所以递归没有层数的限制，只要选取的元素总和超过 target，就直接返回</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">combinationSum</span>(<span class="hljs-params">self, candidates, target</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type candidates: List[int]</span><br><span class="hljs-string">        :type target: int</span><br><span class="hljs-string">        :rtype: List[List[int]]</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        res = []  <span class="hljs-comment"># 用于存储所有符合条件的组合</span><br>        self.backtrack(candidates, target, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, [], res)  <span class="hljs-comment"># 调用回溯函数</span><br>        <span class="hljs-keyword">return</span> res<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">backtrack</span>(<span class="hljs-params">self, candidates, target, total, startIndex, path, res</span>):<br>        <span class="hljs-keyword">if</span> total &gt; target:<br>            <span class="hljs-keyword">return</span><br>        <span class="hljs-keyword">if</span> total == target:<br>            res.append(path[:])  <span class="hljs-comment"># 将当前路径的拷贝存储到结果中</span><br>            <span class="hljs-keyword">return</span><br><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(startIndex, <span class="hljs-built_in">len</span>(candidates)):<br>            total += candidates[i]  <span class="hljs-comment"># 选择当前数字</span><br>            path.append(candidates[i])  <span class="hljs-comment"># 将当前数字加入路径</span><br>            self.backtrack(candidates, target, total, i, path, res)  <span class="hljs-comment"># 表示可以重复读取当前的数</span><br>            total -= candidates[i]  <span class="hljs-comment"># 撤销选择（回溯）</span><br>            path.pop()  <span class="hljs-comment"># 从路径中移除最后一个数字（回溯）</span><br></code></pre></td></tr></table></figure>
<h3 id="40-组合总和Ⅱ">40. 组合总和Ⅱ</h3>
<p>集合（camdidates）中有重复元素，但还不能有重复的组合。</p>
<p>把所有组合求出来，再用 set 或者 map 去重，这样容易超时。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">combinationSum2</span>(<span class="hljs-params">self, candidates, target</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type candidates: List[int]</span><br><span class="hljs-string">        :type target: int</span><br><span class="hljs-string">        :rtype: List[List[int]]</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        res = []<br>        candidates.sort()<br>        self.backtrack(candidates, target, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, [], res)<br>        <span class="hljs-keyword">return</span> res<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">backtrack</span>(<span class="hljs-params">self, candidates, target, total, startIndex, path, res</span>):<br>        <span class="hljs-keyword">if</span> total == target:<br>            res.append(path[:])<br>            <span class="hljs-keyword">return</span><br>        <br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(startIndex, <span class="hljs-built_in">len</span>(candidates)):<br>            <span class="hljs-keyword">if</span> i &gt; startIndex <span class="hljs-keyword">and</span> candidates[i] == candidates[i - <span class="hljs-number">1</span>]:<br>                <span class="hljs-keyword">continue</span><br>            <span class="hljs-keyword">if</span> total + candidates[i] &gt; target:<br>                <span class="hljs-keyword">break</span><br>            <br>            total += candidates[i]<br>            path.append(candidates[i])<br>            self.backtrack(candidates, target, total, i + <span class="hljs-number">1</span>, path, res)<br>            total -= candidates[i]<br>            path.pop()<br></code></pre></td></tr></table></figure>
<h3 id="131-分割回文串">131. 分割回文串</h3>
<p>例如对于字符串abcdef：</p>
<ul>
<li>组合问题：选取一个a之后，在bcdef中再去选取第二个，选取b之后在cdef中再选取第三个…</li>
<li>切割问题：切割一个a之后，在bcdef中再去切割第二段，切割b之后在cdef中再切割第三段…</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">partition</span>(<span class="hljs-params">self, s</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type s: str</span><br><span class="hljs-string">        :rtype: List[List[str]]</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        res = []<br>        self.backtrack(s, <span class="hljs-number">0</span>, [], res)<br>        <span class="hljs-keyword">return</span> res <br>        <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">backtrack</span>(<span class="hljs-params">self, s, startIndex, path, res</span>):<br>        <span class="hljs-keyword">if</span> startIndex == <span class="hljs-built_in">len</span>(s):<br>            res.append(path[:])<br>            <span class="hljs-keyword">return</span><br><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(startIndex, <span class="hljs-built_in">len</span>(s)):<br>            <span class="hljs-comment"># 若反序和正序相同，意味着这是回文串</span><br>            <span class="hljs-keyword">if</span> s[startIndex: i + <span class="hljs-number">1</span>] == s[startIndex: i + <span class="hljs-number">1</span>][::-<span class="hljs-number">1</span>]:<br>                path.append(s[startIndex:i + <span class="hljs-number">1</span>])<br>                self.backtrack(s, i + <span class="hljs-number">1</span>, path, res)  <span class="hljs-comment"># 从下一处进行切割，判断其余是否仍为回文串</span><br>                path.pop()<br></code></pre></td></tr></table></figure>
<h3 id="99-复原-IP-地址">99. 复原 IP 地址</h3>
<h4 id="回溯三部曲">回溯三部曲</h4>
<ul>
<li>递归参数</li>
<li>递归终止条件</li>
<li>单层搜索的逻辑</li>
</ul>
<h4 id="判断字串是否合法">判断字串是否合法</h4>
<p>主要考虑如下三点：</p>
<ul>
<li>段位以 0 为开头的数字不合法</li>
<li>段位里有非正整数字符不合法</li>
<li>段位如果大于 255 不合法</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">restoreIpAddresses</span>(<span class="hljs-params">self, s</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type s: str</span><br><span class="hljs-string">        :rtype: List[str]</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        res = []<br>        self.backtrack(s, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;&quot;</span>, res)<br>        <span class="hljs-keyword">return</span> res<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">backtrack</span>(<span class="hljs-params">self, s, start_index, point_num, current, res</span>):<br>        <span class="hljs-keyword">if</span> point_num == <span class="hljs-number">3</span>:  <span class="hljs-comment"># 逗点数量为3时，分隔结束</span><br>            <span class="hljs-keyword">if</span> self.is_valid(s, start_index, <span class="hljs-built_in">len</span>(s) - <span class="hljs-number">1</span>):<br>                current += s[start_index:]  <span class="hljs-comment"># 添加最后一段子字符串</span><br>                res.append(current)<br>            <span class="hljs-keyword">return</span><br><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(start_index, <span class="hljs-built_in">len</span>(s)):<br>            <span class="hljs-keyword">if</span> self.is_valid(s, start_index, i):<br>                sub = s[start_index:i+<span class="hljs-number">1</span>]<br>                self.backtrack(s, i + <span class="hljs-number">1</span>, point_num + <span class="hljs-number">1</span>, current + sub + <span class="hljs-string">&#x27;.&#x27;</span>, res)<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">break</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">is_valid</span>(<span class="hljs-params">self, s, start, end</span>):<br>        <span class="hljs-keyword">if</span> start &gt; end:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">if</span> s[start] == <span class="hljs-string">&#x27;0&#x27;</span> <span class="hljs-keyword">and</span> start != end:  <span class="hljs-comment"># 0 开头数字不合法</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        num = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(start, end + <span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> s[i].isdigit():<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>            num = num * <span class="hljs-number">10</span> + <span class="hljs-built_in">int</span>(s[i])<br>            <span class="hljs-keyword">if</span> num &gt; <span class="hljs-number">255</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure>
<h3 id="78-子集">78. 子集</h3>
<p>如果把子集问题、组合问题、分割问题都抽象为一棵树的话，<strong>那么组合问题和分割问题都是收集树的叶子节点，而子集问题是找树的所有节点</strong>。</p>
<p>子集也是一种组合问题，因为它的集合是无序的，子集 {1,2} 和子集 {2,1} 是一样的。</p>
<p>既然是无序，取过的元素不会重复取，写回溯算法的时候，for 就要从 startIndex 开始，而不是从 0 开始。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">subsets</span>(<span class="hljs-params">self, nums</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type nums: List[int]</span><br><span class="hljs-string">        :rtype: List[List[int]]</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        res = []<br>        path = []<br>        self.backtrack(nums, <span class="hljs-number">0</span>, path, res)<br>        <span class="hljs-keyword">return</span> res<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">backtrack</span>(<span class="hljs-params">self, nums, startIndex, path, res</span>):<br>        res.append(path[:])<br>        <span class="hljs-keyword">if</span> startIndex &gt;= <span class="hljs-built_in">len</span>(nums):<br>            <span class="hljs-keyword">return</span> <br><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(startIndex, <span class="hljs-built_in">len</span>(nums)):<br>            path.append(nums[i])<br>            self.backtrack(nums, i + <span class="hljs-number">1</span>, path, res)<br>            path.pop()<br></code></pre></td></tr></table></figure>
<h3 id="90-子集Ⅱ">90. 子集Ⅱ</h3>
<p>利用集合去重：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">subsetsWithDup</span>(<span class="hljs-params">self, nums</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type nums: List[int]</span><br><span class="hljs-string">        :rtype: List[List[int]]</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        res = []<br>        path = []<br>        nums.sort()  <span class="hljs-comment"># 去重需要排序</span><br>        self.backtrack(nums, <span class="hljs-number">0</span>, path, res)<br>        <span class="hljs-keyword">return</span> res<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">backtrack</span>(<span class="hljs-params">self, nums, startIndex, path, res</span>):<br>        res.append(path[:])<br>        uset = <span class="hljs-built_in">set</span>()<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(startIndex, <span class="hljs-built_in">len</span>(nums)):<br>            <span class="hljs-keyword">if</span> nums[i] <span class="hljs-keyword">in</span> uset:<br>                <span class="hljs-keyword">continue</span><br>            uset.add(nums[i])<br>            path.append(nums[i])<br>            self.backtrack(nums, i + <span class="hljs-number">1</span>, path, res)<br>            path.pop()<br></code></pre></td></tr></table></figure>
<h3 id="491-递增子序列">491. 递增子序列</h3>
<p>回溯（利用 set 去重）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">findSubsequences</span>(<span class="hljs-params">self, nums</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type nums: List[int]</span><br><span class="hljs-string">        :rtype: List[List[int]]</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        res = []<br>        path = []<br>        self.backtrack(nums, <span class="hljs-number">0</span>, path, res)<br>        <span class="hljs-keyword">return</span> res<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">backtrack</span>(<span class="hljs-params">self, nums, startIndex, path, res</span>):<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(path) &gt; <span class="hljs-number">1</span>:<br>            res.append(path[:])<br>            <span class="hljs-comment"># 这里不加 return，要取树上的节点</span><br><br>        uset = <span class="hljs-built_in">set</span>()<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(startIndex, <span class="hljs-built_in">len</span>(nums)):<br>            <span class="hljs-keyword">if</span>(path <span class="hljs-keyword">and</span> nums[i] &lt; path[-<span class="hljs-number">1</span>]) <span class="hljs-keyword">or</span> nums[i] <span class="hljs-keyword">in</span> uset:<br>                <span class="hljs-keyword">continue</span><br><br>            uset.add(nums[i])<br>            path.append(nums[i])<br>            self.backtrack(nums, i + <span class="hljs-number">1</span>, path, res)<br>            path.pop()<br></code></pre></td></tr></table></figure>
<h3 id="46-全排列">46. 全排列</h3>
<p>首先排列是有序的，也就是说 [1,2] 和 [2,1] 是两个集合，这和之前分析的子集以及组合有不同之处。</p>
<p>使用 <code>used</code> 布尔列表，表示每个元素是否已被使用</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">permute</span>(<span class="hljs-params">self, nums</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type nums: List[int]</span><br><span class="hljs-string">        :rtype: List[List[int]]</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        res = []<br>        path = []<br>        self.backtrack(nums, path, [<span class="hljs-literal">False</span>] * <span class="hljs-built_in">len</span>(nums), res)<br>        <span class="hljs-keyword">return</span> res<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">backtrack</span>(<span class="hljs-params">self, nums, path, used, res</span>):<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(path) == <span class="hljs-built_in">len</span>(nums):<br>            res.append(path[:])<br>            <span class="hljs-keyword">return</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums)):<br>            <span class="hljs-keyword">if</span> used[i]:<br>                <span class="hljs-keyword">continue</span><br>            used[i] = <span class="hljs-literal">True</span><br>            path.append(nums[i])<br>            self.backtrack(nums, path, used, res)<br>            path.pop()<br>            used[i] = <span class="hljs-literal">False</span>  <span class="hljs-comment"># 将当前元素的使用标记重置为未使用</span><br></code></pre></td></tr></table></figure>
<h3 id="47-全排列Ⅱ">47. 全排列Ⅱ</h3>
<p>和上一题的区别在于<strong>给定一个可包含重复数字的序列，要返回所有不重复的全排列</strong>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">permuteUnique</span>(<span class="hljs-params">self, nums</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type nums: List[int]</span><br><span class="hljs-string">        :rtype: List[List[int]]</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        nums.sort()<br>        res = []<br>        path = []<br>        self.backtrack(nums, path, [<span class="hljs-literal">False</span>] * <span class="hljs-built_in">len</span>(nums), res)<br>        <span class="hljs-keyword">return</span> res<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">backtrack</span>(<span class="hljs-params">self, nums, path, used, res</span>):<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(path) == <span class="hljs-built_in">len</span>(nums):<br>            res.append(path[:])<br>            <span class="hljs-keyword">return</span> <br><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums)):<br>            <span class="hljs-comment"># 如果当前数字与前一个相同且前一个未被使用，则跳过以避免重复</span><br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> nums[i] == nums[i - <span class="hljs-number">1</span>] <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> used[i - <span class="hljs-number">1</span>]) <span class="hljs-keyword">or</span> used[i]:<br>                <span class="hljs-keyword">continue</span><br>            used[i] = <span class="hljs-literal">True</span><br>            path.append(nums[i])<br>            self.backtrack(nums, path, used, res)<br>            path.pop()<br>            used[i] = <span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure>
<h3 id="51-N-皇后">51. N 皇后</h3>
<p>n 皇后问题研究的是如何将 n 个皇后放置在 n x n 的棋盘上，并且使皇后彼此之间不能相互攻击。</p>
<p>皇后们的约束条件：</p>
<ul>
<li>不能同行</li>
<li>不能同列</li>
<li>不能同斜线</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">solveNQueens</span>(<span class="hljs-params">self, n</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type n: int</span><br><span class="hljs-string">        :rtype: List[List[str]]</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        res = []  <span class="hljs-comment"># 存储最终结果的二维字符串数组</span><br><br>        chessboard = [<span class="hljs-string">&#x27;.&#x27;</span> * n <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]  <span class="hljs-comment"># 初始化棋盘</span><br>        self.backtrack(n, <span class="hljs-number">0</span>, chessboard, res)<br>        <span class="hljs-keyword">return</span> [[<span class="hljs-string">&#x27;&#x27;</span>.join(row) <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> solution] <span class="hljs-keyword">for</span> solution <span class="hljs-keyword">in</span> res]  <span class="hljs-comment"># 返回结果集</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">backtrack</span>(<span class="hljs-params">self, n, row, chessboard, res</span>):<br>        <span class="hljs-keyword">if</span> row == n:<br>            res.append(chessboard[:])<br>            <span class="hljs-keyword">return</span><br>        <br>        <span class="hljs-keyword">for</span> col <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            <span class="hljs-keyword">if</span> self.isValid(row, col, chessboard):<br>                chessboard[row] = chessboard[row][:col] + <span class="hljs-string">&#x27;Q&#x27;</span> + chessboard[row][col+<span class="hljs-number">1</span>:]  <span class="hljs-comment"># 放置皇后</span><br>                self.backtrack(n, row + <span class="hljs-number">1</span>, chessboard, res)  <span class="hljs-comment"># 递归到下一行</span><br>                chessboard[row] = chessboard[row][:col] + <span class="hljs-string">&#x27;.&#x27;</span> + chessboard[row][col+<span class="hljs-number">1</span>:]  <span class="hljs-comment"># 回溯</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">isValid</span>(<span class="hljs-params">self, row, col, chessboard</span>):<br>        <span class="hljs-comment"># 检查列</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(row):<br>            <span class="hljs-keyword">if</span> chessboard[i][col] == <span class="hljs-string">&#x27;Q&#x27;</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>  <span class="hljs-comment"># 当前列已经存在皇后</span><br>        <br>        <span class="hljs-comment"># 检查 45 度角是否有皇后</span><br>        i, j = row - <span class="hljs-number">1</span>, col - <span class="hljs-number">1</span><br>        <span class="hljs-keyword">while</span> i &gt;= <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> j &gt;= <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">if</span> chessboard[i][j] == <span class="hljs-string">&#x27;Q&#x27;</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>  <span class="hljs-comment"># 左上角已经存在皇后</span><br>            i -= <span class="hljs-number">1</span><br>            j -= <span class="hljs-number">1</span><br>        <br>        <span class="hljs-comment"># 检查 135 度角是否有皇后</span><br>        i, j = row - <span class="hljs-number">1</span>, col + <span class="hljs-number">1</span><br>        <span class="hljs-keyword">while</span> i &gt;= <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> j &lt; <span class="hljs-built_in">len</span>(chessboard):<br>            <span class="hljs-keyword">if</span> chessboard[i][j] == <span class="hljs-string">&#x27;Q&#x27;</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>  <span class="hljs-comment"># 右上角已经出现皇后</span><br>            i -= <span class="hljs-number">1</span><br>            j += <span class="hljs-number">1</span><br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>  <span class="hljs-comment"># 当前位置合法</span><br></code></pre></td></tr></table></figure>
<h3 id="37-解数独">37. 解数独</h3>
<p>判断棋盘是否合法</p>
<ul>
<li>同行是否重复</li>
<li>同列是否重复</li>
<li>9 宫格里是否重复</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">solveSudoku</span>(<span class="hljs-params">self, board</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type board: List[List[str]]</span><br><span class="hljs-string">        :rtype: None Do not return anything, modify board in-place instead.</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        self.backtrack(board)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">backtrack</span>(<span class="hljs-params">self, board</span>):<br>        <span class="hljs-comment"># 若有解，返回 True；若无解，返回 False</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(board)):  <span class="hljs-comment"># 遍历行</span><br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(board[<span class="hljs-number">0</span>])):  <span class="hljs-comment"># 遍历列</span><br>                <span class="hljs-keyword">if</span> board[i][j] != <span class="hljs-string">&#x27;.&#x27;</span>:<br>                    <span class="hljs-keyword">continue</span><br>                <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>):<br>                    <span class="hljs-keyword">if</span> self.isValid(i, j, k, board):<br>                        board[i][j] = <span class="hljs-built_in">str</span>(k)<br>                        <span class="hljs-keyword">if</span> self.backtrack(board):<br>                            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>                        board[i][j] = <span class="hljs-string">&#x27;.&#x27;</span><br>                <span class="hljs-comment"># 若数字1-9都不能成功填入空格，返回 Fasle 无解</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">isValid</span>(<span class="hljs-params">self, row, col, val, board</span>):<br>        <span class="hljs-comment"># 判断同一行是否冲突</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">9</span>):<br>            <span class="hljs-keyword">if</span> board[row][i] == <span class="hljs-built_in">str</span>(val):<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        <span class="hljs-comment"># 判断同一列是否冲突</span><br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">9</span>):<br>            <span class="hljs-keyword">if</span> board[j][col] == <span class="hljs-built_in">str</span>(val):<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        <span class="hljs-comment"># 判断九宫格是否有冲突</span><br>        start_row = (row // <span class="hljs-number">3</span>) * <span class="hljs-number">3</span><br>        start_col = (col // <span class="hljs-number">3</span>) * <span class="hljs-number">3</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(start_row, start_row + <span class="hljs-number">3</span>):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(start_col, start_col + <span class="hljs-number">3</span>):<br>                <span class="hljs-keyword">if</span> board[i][j] == <span class="hljs-built_in">str</span>(val):<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure>
<h2 id="贪心算法">贪心算法</h2>
<p>一般分为如下四步：</p>
<ul>
<li>将问题分解为若干个子问题</li>
<li>找出适合的贪心策略</li>
<li>求解每一个子问题的最优解</li>
<li>将局部最优解堆叠成全局最优解</li>
</ul>
<h3 id="455-分发饼干">455. 分发饼干</h3>
<p>为了满足更多的小孩，就不要造成饼干尺寸的浪费。</p>
<p><strong>这里的局部最优解就是大饼干喂给胃口大的，充分利用饼干尺寸喂饱一个，全局最优就是喂饱尽可能多的小孩。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">findContentChildren</span>(<span class="hljs-params">self, g, s</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type g: List[int]</span><br><span class="hljs-string">        :type s: List[int]</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        g.sort()<br>        s.sort()<br>        index = <span class="hljs-built_in">len</span>(s) - <span class="hljs-number">1</span>  <span class="hljs-comment"># 饼干数组的下标</span><br>        res = <span class="hljs-number">0</span>  <span class="hljs-comment"># 满足孩子的数量</span><br><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(g) - <span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):  <span class="hljs-comment"># 遍历胃口，从最后一个孩子开始</span><br>            <span class="hljs-keyword">if</span> index &gt;= <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> s[index] &gt;= g[i]:<br>                res += <span class="hljs-number">1</span><br>                index -= <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure>
<h3 id="376-摆动序列">376. 摆动序列</h3>
<p>局部最优：删除单调坡度上的节点（不包括单调坡度两端的节点），那么这个坡度就可以有两个局部峰值。</p>
<p>整体最优：整个序列有最多的局部峰值，从而达到最长摆动序列。</p>
<p>实际操作上，其实连删除操作都不用做，题目要求的是最长摆动子序列的长度，所以只需要统计数组的峰值数量就可以了（相当于是删除单一坡度上的节点，然后统计长度）。</p>
<p><strong>这就是使用贪心的地方，让峰值尽可能地保持峰值，然后删除单一坡度上的节点。</strong></p>
<p>需要考虑三种情况：</p>
<ol>
<li>上下坡中有平坡</li>
<li>数组首尾两端</li>
<li>单调坡中有平坡</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">wiggleMaxLength</span>(<span class="hljs-params">self, nums</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type nums: List[int]</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) &lt;= <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(nums)  <span class="hljs-comment"># 如果数组长度为0或1，则返回数组长度</span><br>        curDiff = <span class="hljs-number">0</span><br>        preDiff = <span class="hljs-number">0</span><br>        res = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span>):<br>            curDiff = nums[i + <span class="hljs-number">1</span>] - nums[i]  <span class="hljs-comment"># 计算下一个元素与当前元素地差值</span><br>            <span class="hljs-comment"># 如果遇到一个峰值</span><br>            <span class="hljs-keyword">if</span> (preDiff &lt;= <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> curDiff &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">or</span> (preDiff &gt;= <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> curDiff &lt; <span class="hljs-number">0</span>):<br>                res += <span class="hljs-number">1</span><br>                preDiff = curDiff  <span class="hljs-comment"># 只在摆动变化的时候更新 preDiff</span><br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure>
<h3 id="53-最大子序和">53. 最大子序和</h3>
<p>局部最优：当前 “连续和” 为负数的时候立刻放弃，从下一个元素重新计算 “连续和”，因为负数加上下一个元素 “连续和” 只会越来越小。</p>
<p>全局最优：选取最大 “连续和”。</p>
<p><strong>局部最优的情况下，并记录最大的 “连续和”，可以推出全局最优。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">maxSubArray</span>(<span class="hljs-params">self, nums</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type nums: List[int]</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        res = <span class="hljs-built_in">float</span>(<span class="hljs-string">&quot;-inf&quot;</span>)  <span class="hljs-comment"># 初始化结果为负无穷大</span><br>        count = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums)):<br>            count += nums[i]<br>            <span class="hljs-keyword">if</span> count &gt; res:  <span class="hljs-comment"># 取区间累计的最大值</span><br>                res = count<br>            <span class="hljs-keyword">if</span> count &lt;= <span class="hljs-number">0</span>:  <span class="hljs-comment"># 相当于重置最大子序起始位置</span><br>                count = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure>
<h3 id="122-买卖股票的最佳时机Ⅱ">122. 买卖股票的最佳时机Ⅱ</h3>
<p>首先要清楚两点：</p>
<ul>
<li>只有一只股票！</li>
<li>当前只有买股票或者卖股票的操作</li>
</ul>
<p>想获得利润至少要两天为一个交易单元。</p>
<p>只需要收集每天的正利润就可以，<strong>收集正利润的区间，就是股票买卖的区间，而只需要关注最终利润，不需要记录区间。</strong></p>
<p><strong>局部最优：收集每天的正利润，全局最优：求的最大利润。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">maxProfit</span>(<span class="hljs-params">self, prices</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type prices: List[int]</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        res = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(prices)):<br>            res += <span class="hljs-built_in">max</span>(prices[i] - prices[i - <span class="hljs-number">1</span>], <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure>
<h3 id="55-跳跃游戏">55. 跳跃游戏</h3>
<p>局部最优：每次取最大跳跃步数（取最大覆盖范围）。</p>
<p>整体最优：最后得到整体最大覆盖范围，看是否能到终点。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">canJump</span>(<span class="hljs-params">self, nums</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type nums: List[int]</span><br><span class="hljs-string">        :rtype: bool</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        cover = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>        <br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums)):<br>            <span class="hljs-keyword">if</span> i &lt;= cover:<br>                cover = <span class="hljs-built_in">max</span>(i + nums[i], cover)<br>                <span class="hljs-keyword">if</span> cover &gt;= <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span>:<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure>
<h3 id="45-跳跃游戏Ⅱ">45. 跳跃游戏Ⅱ</h3>
<p>局部最优：当前可移动距离尽可能多走，如果还没到终点，步数加一。</p>
<p>整体最优：一步尽可能多走，从而达到最少步数。</p>
<p><strong>要从覆盖范围出发，不管怎么跳，覆盖范围内一定是可以跳到的，以最小的步数增加覆盖范围，覆盖范围一旦覆盖了终点，得到的就是最少步数。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">jump</span>(<span class="hljs-params">self, nums</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type nums: List[int]</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        cur_dis = <span class="hljs-number">0</span>  <span class="hljs-comment"># 当前覆盖最远距离下标</span><br>        res = <span class="hljs-number">0</span>  <span class="hljs-comment"># 记录走的最大步数</span><br>        next_dis = <span class="hljs-number">0</span>  <span class="hljs-comment"># 下一步覆盖最远距离下标</span><br><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span>):<br>            next_dis = <span class="hljs-built_in">max</span>(i + nums[i], next_dis)  <span class="hljs-comment"># 更新下一步覆盖最远距离下标</span><br>            <span class="hljs-keyword">if</span> i == cur_dis:  <span class="hljs-comment"># 遇到当前覆盖最远距离下标</span><br>                cur_dis = next_dis  <span class="hljs-comment"># 更新当前覆盖最远距离下标</span><br>                res += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure>
<h3 id="1005-K-次取反后最大化的数组和">1005. K 次取反后最大化的数组和</h3>
<p>局部最优：让绝对值大的负数变为正数，当前数值达到最大。</p>
<p>整体最优：整个数组和达到最大。</p>
<ul>
<li>将数组按照绝对值大小从大到小排序，<strong>注意要按照绝对值的大小</strong>。</li>
<li>从前向后遍历，遇到负数将其变为正数，同时 K–。</li>
<li>如果 K 还大于 0，那么反复转变数值最小的元素，将 K 用完。</li>
<li>求和。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">largestSumAfterKNegations</span>(<span class="hljs-params">self, nums, k</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type nums: List[int]</span><br><span class="hljs-string">        :type k: int</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        nums.sort(key=<span class="hljs-keyword">lambda</span> x: <span class="hljs-built_in">abs</span>(x), reverse=<span class="hljs-literal">True</span>)  <span class="hljs-comment"># 按照绝对值降序排序数组</span><br><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums)):  <span class="hljs-comment"># 执行 k 次取反操作</span><br>            <span class="hljs-keyword">if</span> nums[i] &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> k &gt; <span class="hljs-number">0</span>:<br>                nums[i] *= -<span class="hljs-number">1</span><br>                k -= <span class="hljs-number">1</span><br>        <br>        <span class="hljs-keyword">if</span> k % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>:  <span class="hljs-comment"># 如果 k 还有剩余次数，将绝对值最小的元素取反</span><br>            nums[-<span class="hljs-number">1</span>] *= -<span class="hljs-number">1</span><br><br>        res = <span class="hljs-built_in">sum</span>(nums)  <span class="hljs-comment"># 计算数组 nums 的元素和</span><br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure>
<h3 id="134-加油站">134. 加油站</h3>
<p>如果总油量减去总消耗大于等于零，那么一定可以跑完一圈，说明各个站点的加油站剩油量 rest[i] 相加一定是大于等于零的。</p>
<p>每个加油站的剩余量 res[i] 为 gas[i] - cost[i]。</p>
<p>局部最优：当前累加 rest[i] 的和 curSum 一旦小于 0，起始位置至少是 i + 1，因为之前从 i 之前开始一定不行。</p>
<p>全局最优：找到可以跑一圈的起始位置。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">canCompleteCircuit</span>(<span class="hljs-params">self, gas, cost</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type gas: List[int]</span><br><span class="hljs-string">        :type cost: List[int]</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        curSum = <span class="hljs-number">0</span>  <span class="hljs-comment"># 当前累计的剩余油量</span><br>        totalSum = <span class="hljs-number">0</span>  <span class="hljs-comment"># 总剩余油量</span><br>        start = <span class="hljs-number">0</span>  <span class="hljs-comment"># 起始位置</span><br><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(gas)):<br>            curSum += gas[i] - cost[i]<br>            totalSum += gas[i] - cost[i]<br><br>            <span class="hljs-keyword">if</span> curSum &lt; <span class="hljs-number">0</span>:  <span class="hljs-comment"># 当前累计剩余油量 curSum 小于 0</span><br>                start = i + <span class="hljs-number">1</span>  <span class="hljs-comment"># 起始位置更新为 i + 1</span><br>                curSum = <span class="hljs-number">0</span>  <span class="hljs-comment"># curSum 重新从 0 开始累计</span><br>        <br>        <span class="hljs-keyword">if</span> totalSum &lt; <span class="hljs-number">0</span>: <br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>  <span class="hljs-comment"># 总剩余油量 totalSum 小于 0，说明无法环绕一圈</span><br>        <span class="hljs-keyword">return</span> start<br></code></pre></td></tr></table></figure>
<h3 id="135-分发糖果">135. 分发糖果</h3>
<p>一定要确定一边之后，再确定另一边，例如比较每一个孩子的左边，然后再比较右边，<strong>如果两边一起考虑一定会顾此失彼。</strong></p>
<p>先确定右边评分大于左边的情况（也就是从前向后遍历）</p>
<p>局部最优：只要右边评分比左边大，右边的孩子就多一颗糖果。</p>
<p>全局最优：相邻的孩子中，评分高的右孩子获得比左边孩子更多的糖果。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">candy</span>(<span class="hljs-params">self, ratings</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type ratings: List[int]</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        candy = [<span class="hljs-number">1</span>] * <span class="hljs-built_in">len</span>(ratings)<br><br>        <span class="hljs-comment"># 从前向后遍历，处理右侧比左侧评分高的情况</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(ratings)):<br>            <span class="hljs-keyword">if</span> ratings[i] &gt; ratings[i - <span class="hljs-number">1</span>]:<br>                candy[i] = candy[i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span><br><br>        <span class="hljs-comment"># 从后向前遍历，处理左侧比右侧评分高的情况</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(ratings) - <span class="hljs-number">2</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">if</span> ratings[i] &gt; ratings[i + <span class="hljs-number">1</span>]:<br>                candy[i] = <span class="hljs-built_in">max</span>(candy[i], candy[i + <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>)<br><br>        <span class="hljs-comment"># 统计结果</span><br>        res = <span class="hljs-built_in">sum</span>(candy)<br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure>
<h3 id="860-柠檬水找零">860. 柠檬水找零</h3>
<p>只需要维护三种金额的数量，5、10 和 20。</p>
<p>有如下三种情况：</p>
<ul>
<li>账单是 5，直接收下。</li>
<li>账单是 10，消耗一个 5，增加一个 10。</li>
<li>账单是 20，优先消耗一个 10 和一个 5，如果不够，再消耗三个 5。</li>
</ul>
<p>局部最优：遇到账单 20，优先消耗美元 10，完成本次找零。</p>
<p>全局最优：完成全部账单的找零。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">lemonadeChange</span>(<span class="hljs-params">self, bills</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type bills: List[int]</span><br><span class="hljs-string">        :rtype: bool</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        five = <span class="hljs-number">0</span><br>        ten = <span class="hljs-number">0</span><br>        twenty = <span class="hljs-number">0</span><br><br>        <span class="hljs-keyword">for</span> bill <span class="hljs-keyword">in</span> bills:<br>            <span class="hljs-comment"># 收到 5 美元</span><br>            <span class="hljs-keyword">if</span> bill == <span class="hljs-number">5</span>:<br>                five += <span class="hljs-number">1</span><br><br>            <span class="hljs-comment"># 收到 10 美元</span><br>            <span class="hljs-keyword">if</span> bill == <span class="hljs-number">10</span>:<br>                <span class="hljs-keyword">if</span> five &lt;= <span class="hljs-number">0</span>:<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>                ten += <span class="hljs-number">1</span><br>                five -= <span class="hljs-number">1</span><br><br>            <span class="hljs-comment"># 收到 20 美元</span><br>            <span class="hljs-keyword">if</span> bill == <span class="hljs-number">20</span>:<br>                <span class="hljs-keyword">if</span> five &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> ten &gt; <span class="hljs-number">0</span>:<br>                    five -= <span class="hljs-number">1</span><br>                    ten -= <span class="hljs-number">1</span><br>                <span class="hljs-keyword">elif</span> five &gt;= <span class="hljs-number">3</span>:<br>                    five -= <span class="hljs-number">3</span><br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure>
<h3 id="406-根据身高重建队列">406. 根据身高重建队列</h3>
<p>如果按照 k 来从小到大排序，排完之后会发现 k 的排列并不符合条件，身高也不符合条件，两个维度都没确定。</p>
<p>按照身高 h 来排序，身高一定是从大到小排（身高相同的话则 k 小的站前面），让高个子在前面。</p>
<p><strong>此时可以确定一个维度了，就是身高，前面的节点一定都比本节点高！</strong></p>
<p>局部最优：优先按身高高的 people 的 k 来插入，插入操作过后的 people 满足队列属性。</p>
<p>全局最优：最后都做完插入操作，整个队列满足题目队列属性。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">reconstructQueue</span>(<span class="hljs-params">self, people</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type people: List[List[int]]</span><br><span class="hljs-string">        :rtype: List[List[int]]</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-comment"># 先按照h维度的身高顺序从高到低排序。确定第一个维度</span><br>        <span class="hljs-comment"># lambda返回的是一个元组：当-x[0](维度h）相同时，再根据x[1]（维度k）从小到大排序</span><br>        people.sort(key=<span class="hljs-keyword">lambda</span> x: (-x[<span class="hljs-number">0</span>], x[<span class="hljs-number">1</span>]))<br>        queue = []<br><br>        <span class="hljs-comment"># 根据每个元素的第二个维度k，贪心算法，进行插入</span><br>        <span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> people:<br>            queue.insert(p[<span class="hljs-number">1</span>], p)<br>        <span class="hljs-keyword">return</span> queue<br></code></pre></td></tr></table></figure>
<h3 id="452-用最小数量的箭引爆气球">452. 用最小数量的箭引爆气球</h3>
<p>局部最优：当气球出现重叠，一起射，所用弓箭最少。</p>
<p>全局最优：把所有气球射爆所用弓箭最少。</p>
<p><strong>为了让气球尽可能重叠，需要对数组进行排序。</strong></p>
<p>按照起始位置排序，那么就从前向后遍历气球数组，靠左尽可能让气球重复。</p>
<p><strong>如果气球重叠了，重叠气球中右边边界的最小值之间的区间一定需要一个弓箭。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">findMinArrowShots</span>(<span class="hljs-params">self, points</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type points: List[List[int]]</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(points) == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        <br>        points.sort(key = <span class="hljs-keyword">lambda</span> x: x[<span class="hljs-number">0</span>])<br><br>        cur_min_right = points[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]<br>        count = <span class="hljs-number">1</span><br><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> points:<br>            <span class="hljs-keyword">if</span> i[<span class="hljs-number">0</span>] &gt; cur_min_right:<br>                <span class="hljs-comment"># 当前气球左侧大于这个阈值，那么一定就需要再发射一只箭，并且将阈值更新为当前气球的右侧</span><br>                count += <span class="hljs-number">1</span><br>                cur_min_right = i[<span class="hljs-number">1</span>]<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-comment"># 否则，只需要求阈值和当前气球的右侧较小值来更新阈值</span><br>                cur_min_right = <span class="hljs-built_in">min</span>(cur_min_right, i[<span class="hljs-number">1</span>])<br>        <span class="hljs-keyword">return</span> count<br></code></pre></td></tr></table></figure>
<h3 id="435-无重叠区间">435. 无重叠区间</h3>
<p><strong>按照右边界排序，从左向右记录非交叉区间的个数。最后用区间总数减去非交叉区间的个数就是需要移除的区间个数了。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">eraseOverlapIntervals</span>(<span class="hljs-params">self, intervals</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type intervals: List[List[int]]</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> intervals:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br><br>        intervals.sort(key = <span class="hljs-keyword">lambda</span> x: x[<span class="hljs-number">1</span>])  <span class="hljs-comment"># 按照右边界升序排序</span><br><br>        result = <span class="hljs-number">1</span><br><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(intervals)):<br>            <span class="hljs-keyword">if</span> intervals[i][<span class="hljs-number">0</span>] &gt;= intervals[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]:  <span class="hljs-comment"># 没有重叠</span><br>                result += <span class="hljs-number">1</span><br>                intervals[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = intervals[i][<span class="hljs-number">1</span>]  <span class="hljs-comment"># 更新重叠区间的右边界</span><br><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(intervals) - result<br></code></pre></td></tr></table></figure>
<h3 id="763-划分字母区间">763. 划分字母区间</h3>
<p>在遍历的过程中相当于是要找每一个字母的边界，**如果找到之前遍历过的所有字母的最远边界，说明这个边界就是分割点了。**此时前面出现过所有字母，最远也就到这个边界了。</p>
<ul>
<li>统计每一个字符最后出现的位置。</li>
<li>从头遍历字符，并更新字符的最远出现下标，如果找到字符最远出现位置下标和当前下标相等了，则找到了分割点。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">partitionLabels</span>(<span class="hljs-params">self, s</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type s: str</span><br><span class="hljs-string">        :rtype: List[int]</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        last_occur = &#123;&#125;  <span class="hljs-comment"># 存储每个字符最后出现的位置</span><br>        <span class="hljs-keyword">for</span> i, char <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(s):<br>            last_occur[char] = i<br><br>        res = []<br>        start = <span class="hljs-number">0</span><br>        end = <span class="hljs-number">0</span><br><br>        <span class="hljs-keyword">for</span> i, char <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(s):<br>            end = <span class="hljs-built_in">max</span>(end, last_occur[char])  <span class="hljs-comment"># 找到当前字符出现的最远位置</span><br>            <span class="hljs-keyword">if</span> i == end:  <span class="hljs-comment"># 如果当前位置是最远位置，表示可以分割出一个区间</span><br>                res.append(end - start + <span class="hljs-number">1</span>)<br>                start = i + <span class="hljs-number">1</span><br>            <br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure>
<h3 id="56-合并区间">56. 合并区间</h3>
<p>先排序，让所有的相邻区间尽可能的重叠在一起，按左边界或者右边界排序都可以，处理逻辑稍有不同。</p>
<p>模拟合并区间，用合并区间后左边界和右边界，作为一个新的区间，加入到 result 数组里就可以了。如果没有合并就把原区间加入到 result 数组。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">merge</span>(<span class="hljs-params">self, intervals</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type intervals: List[List[int]]</span><br><span class="hljs-string">        :rtype: List[List[int]]</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        res = []<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> intervals:<br>            <span class="hljs-keyword">return</span> res  <span class="hljs-comment"># 区间集合为空，直接返回</span><br><br>        intervals.sort(key = <span class="hljs-keyword">lambda</span> x: x[<span class="hljs-number">0</span>])  <span class="hljs-comment"># 按照左边界进行排序</span><br><br>        res.append(intervals[<span class="hljs-number">0</span>])<br><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(intervals)):<br>            <span class="hljs-keyword">if</span> res[-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] &gt;= intervals[i][<span class="hljs-number">0</span>]:  <span class="hljs-comment"># 发现重叠区间</span><br>                <span class="hljs-comment"># 合并区间，只需要更新结果集最后一个区间的右边界</span><br>                res[-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(res[-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>], intervals[i][<span class="hljs-number">1</span>])<br>            <span class="hljs-keyword">else</span>:<br>                res.append(intervals[i])  <span class="hljs-comment"># 区间不重叠</span><br><br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure>
<h3 id="738-单调递增的数字">738. 单调递增的数字</h3>
<p>举例：数字 332 从前向后遍历的话，变成 329，此时 2 又小于了第一位的 3，真正的结果应该是 299。</p>
<p>那么从后向前遍历，就可以重复利用上次比较得出的结果，从后向前遍历 332 的数值变化为：332 -&gt; 329 -&gt; 299。</p>
<p><strong>采用从后向前遍历</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">monotoneIncreasingDigits</span>(<span class="hljs-params">self, n</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type n: int</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-comment"># 将整数转换为字符串</span><br>        strNum = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">str</span>(n))<br><br>        <span class="hljs-comment"># 从右往左遍历字符串</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(strNum) - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>):<br>            <span class="hljs-comment"># 如果当前字符比前一个字符小，说明需要修改前一个字符</span><br>            <span class="hljs-keyword">if</span> strNum[i - <span class="hljs-number">1</span>] &gt; strNum[i]:<br>                strNum[i - <span class="hljs-number">1</span>] = <span class="hljs-built_in">str</span>(<span class="hljs-built_in">int</span>(strNum[i - <span class="hljs-number">1</span>]) - <span class="hljs-number">1</span>)  <span class="hljs-comment"># 将前一个字符减 1</span><br><br>                <span class="hljs-comment"># 将修改位置后面的字符都设置为 9， 因为修改前一个字符可能破坏了递增性质</span><br>                <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i, <span class="hljs-built_in">len</span>(strNum)):<br>                    strNum[j] = <span class="hljs-string">&#x27;9&#x27;</span><br><br>        <span class="hljs-comment"># 将列表转换为字符串，并将字符串转换为整数并返回</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">int</span>(<span class="hljs-string">&#x27;&#x27;</span>.join(strNum))<br></code></pre></td></tr></table></figure>
<h3 id="986-监控二叉树">986. 监控二叉树</h3>
<p>摄像头可以覆盖上中下三层，如果把摄像头放在叶子节点上，就浪费了一层的覆盖。</p>
<p>所以把摄像头放在叶子节点的父节点的位置，才能充分利用摄像头的覆盖面积。</p>
<p><strong>局部最优</strong>：让叶子节点的父节点安摄像头，所用摄像头最少。</p>
<p><strong>全局最优</strong>：全部摄像头数量所用最少。</p>
<p>可以使用后序遍历也就是左右中的顺序，这样就可以在回溯的过程中从下到上进行推导了。</p>
<p>每个节点可能有几种状态：</p>
<ul>
<li>该节点无覆盖</li>
<li>本节点有摄像头</li>
<li>本节点有覆盖</li>
</ul>
<p>情况 1：左右节点都有覆盖</p>
<p>左孩子有覆盖，右孩子有覆盖，那么此时中间节点应该是无覆盖的状态。</p>
<p>情况 2：左右节点至少有一个无覆盖的情况</p>
<p>如果是以下情况，则中间节点（父节点）应该放摄像头：</p>
<ul>
<li>left == 0 &amp;&amp; right == 0 左右节点无覆盖</li>
<li>left == 1 &amp;&amp; right == 0 左节点有摄像头，右节点无覆盖</li>
<li>left == 0 &amp;&amp; right == 1 左节点无覆盖，右节点摄像头</li>
<li>left == 0 &amp;&amp; right == 2 左节点无覆盖，右节点覆盖</li>
<li>left == 2 &amp;&amp; right == 0 左节点覆盖，右节点无覆盖</li>
</ul>
<p>情况 3：左右节点至少有一个摄像头</p>
<p>如果是以下情况，其实就是左右孩子节点有一个摄像头了，那么其父节点就应该是 2（覆盖的状态）</p>
<ul>
<li>left == 1 &amp;&amp; right == 2 左节点有摄像头，右节点有覆盖</li>
<li>left == 2 &amp;&amp; right == 1 左节点有覆盖，右节点有摄像头</li>
<li>left == 1 &amp;&amp; right == 1 左右节点都有摄像头</li>
</ul>
<p>情况 4：头结点没有覆盖</p>
<p>以上都处理完了，递归结束之后，可能头结点还有一个无覆盖的情况。</p>
<p>贪心 + 二叉树代码实现</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Definition for a binary tree node.</span><br><span class="hljs-comment"># class TreeNode(object):</span><br><span class="hljs-comment">#     def __init__(self, val=0, left=None, right=None):</span><br><span class="hljs-comment">#         self.val = val</span><br><span class="hljs-comment">#         self.left = left</span><br><span class="hljs-comment">#         self.right = right</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minCameraCover</span>(<span class="hljs-params">self, root</span>):<br>        <span class="hljs-comment"># 0: 该节点未覆盖</span><br>        <span class="hljs-comment"># 1: 该节点有摄像头</span><br>        <span class="hljs-comment"># 2: 该节点有覆盖</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type root: Optional[TreeNode]</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        res = [<span class="hljs-number">0</span>]  <span class="hljs-comment"># 用于记录摄像头的安装数量</span><br>        <span class="hljs-keyword">if</span> self.traversal(root, res) == <span class="hljs-number">0</span>:<br>            res[<span class="hljs-number">0</span>] += <span class="hljs-number">1</span><br><br>        <span class="hljs-keyword">return</span> res[<span class="hljs-number">0</span>]<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">traversal</span>(<span class="hljs-params">self, cur, res</span>):<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> cur:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">2</span><br><br>        left = self.traversal(cur.left, res)<br>        right = self.traversal(cur.right, res)<br><br>        <span class="hljs-comment"># 左右节点都有覆盖</span><br>        <span class="hljs-keyword">if</span> left == <span class="hljs-number">2</span> <span class="hljs-keyword">and</span> right == <span class="hljs-number">2</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br><br>        <span class="hljs-comment"># 左右节点至少有一个无覆盖的情况</span><br>        <span class="hljs-keyword">if</span> left == <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> right == <span class="hljs-number">0</span>:<br>            res[<span class="hljs-number">0</span>] += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br><br>        <span class="hljs-comment"># 左右节点至少有一个摄像头</span><br>        <span class="hljs-keyword">if</span> left == <span class="hljs-number">1</span> <span class="hljs-keyword">or</span> right == <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure>
<h2 id="动态规划">动态规划</h2>
<p>如果某一问题有很多重叠子问题，使用动态规划是最有效的。</p>
<p>动态规划中每一个状态一定是由上一个状态推导出来的，<strong>这一点区分于贪心</strong>，贪心没有状态推导，而是从局部直接选取最优的。</p>
<p>动态规划五部曲：</p>
<ol>
<li>确定 dp 数组（dp table）以及下标的含义</li>
<li>确定递推公式</li>
<li>dp 数组如何初始化</li>
<li>确定遍历顺序</li>
<li>举例推导 dp 数组</li>
</ol>
<p>灵魂三问？</p>
<ul>
<li>举例推导状态转移公式了吗？</li>
<li>打印 dp 数组的日志了吗？</li>
<li>打印出来的 dp 数组和我想的一样吗？</li>
</ul>
<h3 id="509-斐波那契数">509. 斐波那契数</h3>
<ol>
<li>
<p>确定 dp 数组以及下标的含义</p>
<p>dp[i] 的定义为：第 i 个数的斐波那契数值是 dp[i]</p>
</li>
<li>
<p>确定递推公式</p>
<p>状态转移方程 dp[i] = dp[i - 1] + dp[i - 2]</p>
</li>
<li>
<p>dp 数组如何初始化</p>
<p>dp[0] = 0, dp[1] = 1</p>
</li>
<li>
<p>确定遍历顺序</p>
<p>dp[i] 是依赖 dp[i - 1] 和 dp[i - 2]，那么遍历的顺序一定是从前到后遍历的</p>
</li>
<li>
<p>举例推导 dp 数组</p>
<p>当 N 为 10 的时候，dp 数组应该是如下的数列：</p>
<p>0 1 1 2 3 5 8 13 21 34 55</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">fib</span>(<span class="hljs-params">self, n</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type n: int</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br><br>        <span class="hljs-comment"># 创建 dp table</span><br>        dp = [<span class="hljs-number">0</span>] * (n + <span class="hljs-number">1</span>)<br><br>        <span class="hljs-comment"># 初始化 dp 数组</span><br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span><br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span><br><br>        <span class="hljs-comment"># 遍历顺序：由前向后</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>, n + <span class="hljs-number">1</span>):<br>            <span class="hljs-comment"># 确定递推公式</span><br>            dp[i] = dp[i - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">2</span>]<br><br>        <span class="hljs-keyword">return</span> dp[n]<br></code></pre></td></tr></table></figure>
<h3 id="70-爬楼梯">70. 爬楼梯</h3>
<ol>
<li>
<p>确定 dp 数组以及下标的含义</p>
<p>dp[i]：爬到第 i 层楼梯，有 dp[i] 种方法</p>
</li>
<li>
<p>确定递推公式</p>
<p>状态转移方程 dp[i] = dp[i - 1] + dp[i - 2]</p>
</li>
<li>
<p>dp 数组如何初始化</p>
<p>dp[1] = 1, dp[2] = 2</p>
</li>
<li>
<p>确定遍历顺序</p>
<p>dp[i] 是依赖 dp[i - 1] 和 dp[i - 2]，那么遍历的顺序一定是从前到后遍历的</p>
</li>
<li>
<p>举例推导 dp 数组</p>
<p>当 N 为 5 的时候，dp 数组应该是如下的数列：</p>
<p>1 2 3 5 8</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">climbStairs</span>(<span class="hljs-params">self, n</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type n: int</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> n &lt;= <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">return</span> n<br><br>        <span class="hljs-comment"># 创建 dp table</span><br>        dp = [<span class="hljs-number">0</span>] * (n + <span class="hljs-number">1</span>)<br><br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span><br>        dp[<span class="hljs-number">2</span>] = <span class="hljs-number">2</span><br><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>, n + <span class="hljs-number">1</span>):<br>            <span class="hljs-comment"># 确定递推公式</span><br>            dp[i] = dp[i - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">2</span>]<br>        <br>        <span class="hljs-keyword">return</span> dp[n]<br></code></pre></td></tr></table></figure>
<h3 id="746-使用最小花费爬楼梯">746. 使用最小花费爬楼梯</h3>
<ol>
<li>
<p>确定 dp 数组以及下标的含义</p>
<p>dp[i] 的定义：到达第 i 台阶所花费的最少体力为 dp[i]</p>
</li>
<li>
<p>确定递推公式</p>
<p>状态转移方程 dp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2])</p>
</li>
<li>
<p>dp 数组如何初始化</p>
<p>dp[0] = 0, dp[1] = 0</p>
</li>
<li>
<p>确定遍历顺序</p>
<p>dp[i] 是依赖 dp[i - 1] 和 dp[i - 2]，那么遍历的顺序一定是从前到后遍历的</p>
</li>
<li>
<p>举例推导 dp 数组</p>
<p>cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]，dp 数组应该是如下的数列：</p>
<p>0 0 1 2 2 3 3 4 4 5 6</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minCostClimbingStairs</span>(<span class="hljs-params">self, cost</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type cost: List[int]</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        dp = [<span class="hljs-number">0</span>] * (<span class="hljs-built_in">len</span>(cost) + <span class="hljs-number">1</span>)<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span><br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span><br><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>, <span class="hljs-built_in">len</span>(cost) + <span class="hljs-number">1</span>):<br>            <span class="hljs-comment"># 选择其中花费体力较小的路径，加上当前步的花费，更新 dp 数组</span><br>            dp[i] = <span class="hljs-built_in">min</span>(dp[i - <span class="hljs-number">1</span>] + cost[i - <span class="hljs-number">1</span>], dp[i - <span class="hljs-number">2</span>] + cost[i - <span class="hljs-number">2</span>])<br><br>        <span class="hljs-comment"># 返回到达楼顶的最小花费</span><br>        <span class="hljs-keyword">return</span> dp[<span class="hljs-built_in">len</span>(cost)]<br></code></pre></td></tr></table></figure>
<h3 id="62-不同路径">62. 不同路径</h3>
<p>最直观的想法就是用图论里的深搜，来枚举出来有多少种路径。机器人每次只能向下或向右移动一步，其实<strong>机器人走过的路径可以抽象为一棵二叉树，而叶子节点就是终点。</strong></p>
<p><strong>动态规划实现</strong></p>
<ol>
<li>
<p>确定 dp 数组以及下标的含义</p>
<p><code>dp[i][j]</code>：表示从（0，0）出发，到（i, j）有 <code>dp[i][j]</code>条不同的路径。</p>
</li>
<li>
<p>确定递推公式</p>
<p>状态转移方程 <code>dp[i][j]</code> = <code>dp[i - 1][j]</code> + <code>dp[i][j - 1]</code>，因为 <code>dp[i][j]</code>只有这两个方向过来。</p>
</li>
<li>
<p>dp 数组如何初始化</p>
<p><code>dp[i][0]</code> = 1, <code>dp[0][j]</code> = 1</p>
</li>
<li>
<p>确定遍历顺序</p>
<p><code>dp[i][j]</code>都是从其上方和左方推导而来，那么从左到右一层层遍历即可。</p>
</li>
<li>
<p>举例推导 dp 数组</p>
<table>
<thead>
<tr>
<th>1</th>
<th>1</th>
<th>1</th>
<th>1</th>
<th>1</th>
<th>1</th>
<th>1</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>7</td>
</tr>
<tr>
<td>1</td>
<td>3</td>
<td>6</td>
<td>10</td>
<td>15</td>
<td>21</td>
<td>28</td>
</tr>
</tbody>
</table>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">uniquePaths</span>(<span class="hljs-params">self, m, n</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type m: int</span><br><span class="hljs-string">        :type n: int</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-comment"># 创建一个二维列表用于存储唯一路径</span><br>        dp = [[<span class="hljs-number">0</span>] * n <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m)]<br><br>        <span class="hljs-comment"># 设置第一行和第一列的基本情况</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):<br>            dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">1</span><br><br>        <span class="hljs-comment"># 计算每个单元格的唯一路径数</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, m):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n):<br>                dp[i][j] = dp[i - <span class="hljs-number">1</span>][j] + dp[i][j - <span class="hljs-number">1</span>]<br><br>        <span class="hljs-comment"># 返回右下角单元格的唯一路径数</span><br>        <span class="hljs-keyword">return</span> dp[m - <span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure>
<h3 id="63-不同路径Ⅱ">63. 不同路径Ⅱ</h3>
<ol>
<li>
<p>确定 dp 数组以及下标的含义</p>
<p><code>dp[i][j]</code>：表示从（0，0）出发，到（i, j）有 <code>dp[i][j]</code>条不同的路径。</p>
</li>
<li>
<p>确定递推公式</p>
<p>状态转移方程 <code>dp[i][j]</code> = <code>dp[i - 1][j]</code> + <code>dp[i][j - 1]</code>，但因为有了障碍，（i, j）如果就是障碍的话应该保持初始状态（初始状态为 0）。</p>
</li>
<li>
<p>dp 数组如何初始化</p>
<p><code>dp[i][0]</code> = 1, <code>dp[0][j]</code> = 1</p>
</li>
<li>
<p>确定遍历顺序</p>
<p><code>dp[i][j]</code>都是从其上方和左方推导而来，那么从左到右一层层遍历即可。</p>
</li>
<li>
<p>举例推导 dp 数组</p>
<table>
<thead>
<tr>
<th>1</th>
<th>1</th>
<th>1</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>2</td>
</tr>
</tbody>
</table>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">uniquePathsWithObstacles</span>(<span class="hljs-params">self, obstacleGrid</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type obstacleGrid: List[List[int]]</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        m = <span class="hljs-built_in">len</span>(obstacleGrid)  <span class="hljs-comment"># 网格的行数</span><br>        n = <span class="hljs-built_in">len</span>(obstacleGrid[<span class="hljs-number">0</span>])  <span class="hljs-comment"># 网格的列数</span><br><br>        <span class="hljs-keyword">if</span> obstacleGrid[m - <span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>] == <span class="hljs-number">1</span> <span class="hljs-keyword">or</span> obstacleGrid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] == <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br><br>        <span class="hljs-comment"># 创建一个二维列表用于存储路径数</span><br>        dp = [[<span class="hljs-number">0</span>] * n <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m)]<br><br>        <span class="hljs-comment"># 设置起点的路径数为 1</span><br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span> <span class="hljs-keyword">if</span> obstacleGrid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] == <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> <span class="hljs-number">0</span><br><br>        <span class="hljs-comment"># 计算第一列的路径数</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, m):<br>            <span class="hljs-keyword">if</span> obstacleGrid[i][<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>:<br>                dp[i][<span class="hljs-number">0</span>] = dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>]<br>            <br>        <span class="hljs-comment"># 计算第一行的路径数</span><br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n):<br>            <span class="hljs-keyword">if</span> obstacleGrid[<span class="hljs-number">0</span>][j] == <span class="hljs-number">0</span>:<br>                dp[<span class="hljs-number">0</span>][j] = dp[<span class="hljs-number">0</span>][j - <span class="hljs-number">1</span>]<br><br>        <span class="hljs-comment"># 计算其他位置的路径数</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, m):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n):<br>                <span class="hljs-keyword">if</span> obstacleGrid[i][j] == <span class="hljs-number">1</span>:<br>                    <span class="hljs-keyword">continue</span><br>                dp[i][j] = dp[i - <span class="hljs-number">1</span>][j] + dp[i][j - <span class="hljs-number">1</span>]<br><br>        <span class="hljs-comment"># 返回终点的路径数</span><br>        <span class="hljs-keyword">return</span> dp[m - <span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure>
<h3 id="416-分割等和子集">416. 分割等和子集</h3>
<p>首先，要求集合里能否出现总和为 sum / 2 的子集。</p>
<p>动规五部曲：</p>
<ol>
<li>
<p>确定 dp 数组以及下标的含义</p>
<p>dp[j] 表示：容量（所能装的重量）为 j 的背包，所背的物品价值最大可以为 dp[j]。</p>
</li>
<li>
<p>确定递推公式</p>
<p>递推公式：dp[j] = max(dp[j], dp[j - nums[i]] + nums[i])</p>
</li>
<li>
<p>dp 数组如何初始化</p>
<p>dp[0] = 0</p>
<p>题目中只包含正整数的非空数组，所以非 0 下标的元素初始化为 0 即可。</p>
</li>
<li>
<p>确定遍历顺序</p>
<p>如果使用一维 dp 数组，物品遍历的 for 循环放在外层，遍历背包的 for 循环放在内层，且内层 for 循环倒序遍历。</p>
</li>
<li>
<p>举例推导 dp 数组</p>
<p>dp[j] 的数值一定是小于等于 j 的。</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">canPartition</span>(<span class="hljs-params">self, nums</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type nums: List[int]</span><br><span class="hljs-string">        :rtype: bool</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        total = <span class="hljs-number">0</span><br><br>        dp = [<span class="hljs-number">0</span>] * <span class="hljs-number">10001</span><br>        <span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> nums:<br>            total += num<br>        <br>        <span class="hljs-keyword">if</span> total % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        target = total // <span class="hljs-number">2</span><br><br>        <span class="hljs-comment"># 开始 0-1 背包</span><br>        <span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> nums:<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(target, num - <span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):<br>                dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j - num] + num)<br><br>        <span class="hljs-comment"># 集合中的元素正好可以凑成总和 target</span><br>        <span class="hljs-keyword">if</span> dp[target] == target:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure>
<h3 id="1049-最后一块石头的重量Ⅱ">1049. 最后一块石头的重量Ⅱ</h3>
<p>尽量让石头分成重量相同的两堆（尽可能相同），相撞之后剩下的石头就是最小的。</p>
<p>一堆的石头重量是 sum，尽可能拼成重量为 sum / 2 的石头堆。</p>
<p>动规五部曲：</p>
<ol>
<li>
<p>确定 dp 数组以及下标的含义</p>
<p>dp[j] 表示容量（其实就是重量）为 j 的背包，最多可以背最大重量为 dp[j]。</p>
</li>
<li>
<p>确定递推公式</p>
<p>递推公式：dp[j] = max(dp[j], dp[j - stones[i]] + stones[i])</p>
</li>
<li>
<p>dp 数组如何初始化</p>
<p>dp[j] = 0</p>
</li>
<li>
<p>确定遍历顺序</p>
<p>如果使用一维 dp 数组，物品遍历的 for 循环放在外层，遍历背包的 for 循环放在内层，且内层 for 循环倒序遍历。</p>
</li>
<li>
<p>举例推导 dp 数组</p>
<p>输入：[2, 4, 1, 1]，此时 target = (2 + 4 + 1 + 1) / 2 = 4</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">lastStoneWeightII</span>(<span class="hljs-params">self, stones</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type stones: List[int]</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        dp = [<span class="hljs-number">0</span>] * <span class="hljs-number">15001</span><br>        total_sum = <span class="hljs-built_in">sum</span>(stones)<br>        target = total_sum // <span class="hljs-number">2</span><br><br>        <span class="hljs-keyword">for</span> stone <span class="hljs-keyword">in</span> stones:  <span class="hljs-comment"># 遍历物品</span><br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(target, stone - <span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):  <span class="hljs-comment"># 遍历背包</span><br>                dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j - stone] + stone)<br><br>        <span class="hljs-keyword">return</span> total_sum - dp[target] - dp[target]<br></code></pre></td></tr></table></figure>
<h3 id="494-目标和">494. 目标和</h3>
<p>如何使表达式结果为 target？</p>
<p>既然为 target，那么一定有 left 组合 - right 组合 = target。</p>
<p>left + right = sum，而 sum 使固定的。right = sum - left。</p>
<p>left - (sum - left) = target 推导出 left = (target + sum) / 2。</p>
<p>target 是固定的，sum 是固定的，left 就可以求出来。</p>
<p>此时问题就是在集合 nums 中找出和为 left 的组合。</p>
<p>动规五部曲：</p>
<ol>
<li>
<p>确定 dp 数组以及下标的含义</p>
<p><code>dp[i][j]</code>：使用下标为 [0, i] 的 nums[i] 能够凑满 j（包括 j）这么大容量的包，有 <code>dp[i][j]</code> 种方法。</p>
</li>
<li>
<p>确定递推公式</p>
<p>不放物品 i：即背包容量为 j，里面不放物品 i，装满有 <code>dp[i - 1][j]</code> 种方法。</p>
<p>放物品 i：即空出物品 i 的容量，背包容量为（j - 物品 i 容量），放满背包有 <code>dp[i - 1][j - 物品 i 容量]</code> 种方法。</p>
<p>递推公式：<code>dp[i][j] = dp[i - 1][j] + dp[i - 1][j - nums[i]]</code></p>
</li>
<li>
<p>dp 数组如何初始化</p>
<p><code>dp[i][0]</code> = 1</p>
</li>
<li>
<p>确定遍历顺序</p>
<p>从上到下，从左到右。只有这样，才能基于之前的数值做推导。</p>
</li>
<li>
<p>举例推导 dp 数组</p>
<p>输入：nums: [1, 1, 1, 1, 1]，target：3</p>
<p>bagSize = (target + sum) / 2 = (3 + 5) / 2 = 4</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">findTargetSumWays</span>(<span class="hljs-params">self, nums, target</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type nums: List[int]</span><br><span class="hljs-string">        :type target: int</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        total_sum = <span class="hljs-built_in">sum</span>(nums)  <span class="hljs-comment"># 计算 nums 的总和</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">abs</span>(target) &gt; total_sum:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        <span class="hljs-keyword">if</span> (target + total_sum) % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        target_sum = (target + total_sum) // <span class="hljs-number">2</span>  <span class="hljs-comment"># 目标和</span><br>        dp = [<span class="hljs-number">0</span>] * (target_sum + <span class="hljs-number">1</span>)<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> nums:<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(target_sum, num - <span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):<br>                dp[j] += dp[j - num]  <span class="hljs-comment"># 状态转移方程</span><br>        <span class="hljs-keyword">return</span> dp[target_sum]<br></code></pre></td></tr></table></figure>
<h3 id="474-一和零">474. 一和零</h3>
<p><strong>本题中 strs 数组里的元素就是物品，每个物品都是一个！而 m 和 n 相当于是一个背包，两个维度的背包。</strong></p>
<p>动规五部曲：</p>
<ol>
<li>
<p>确定 dp 数组以及下标的含义</p>
<p><code>dp[i][j]</code>：最多有 i 个 0 和 j 个 1 的 strs 的最大子集的大小为 <code>dp[i][j]</code>。</p>
</li>
<li>
<p>确定递推公式</p>
<p>不放物品 i：即背包容量为 j，里面不放物品 i，装满有 <code>dp[i - 1][j]</code> 种方法。</p>
<p>放物品 i：即空出物品 i 的容量，背包容量为（j - 物品 i 容量），放满背包有 <code>dp[i - 1][j - 物品 i 容量]</code> 种方法。</p>
<p>递推公式：<code>dp[i][j] = max(dp[i][j], dp[i - zeroNum][j - oneNum] + 1)</code></p>
</li>
<li>
<p>dp 数组如何初始化</p>
<p>因为物品价值不会是负数，初始为 0，保证递推的时候 <code>dp[i][j]</code> 不会被初始值覆盖。</p>
</li>
<li>
<p>确定遍历顺序</p>
<p>外层 for 循环遍历物品，内层 for 循环遍历背包容量且从后向前遍历。</p>
<p>本题也是，物品就是 strs 里的字符串，背包容量就是题目描述中的 m 和 n。</p>
</li>
<li>
<p>举例推导 dp 数组</p>
<p>输入：[“10”,“0001”,“111001”,“1”,“0”]，m = 3，n = 3</p>
<table>
<thead>
<tr>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>2</td>
<td>2</td>
<td>2</td>
</tr>
<tr>
<td>1</td>
<td>2</td>
<td>3</td>
<td>3</td>
</tr>
<tr>
<td>1</td>
<td>2</td>
<td>3</td>
<td>3</td>
</tr>
</tbody>
</table>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">findMaxForm</span>(<span class="hljs-params">self, strs, m, n</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type strs: List[str]</span><br><span class="hljs-string">        :type m: int</span><br><span class="hljs-string">        :type n: int</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        dp = [[<span class="hljs-number">0</span>] * (n + <span class="hljs-number">1</span>) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m + <span class="hljs-number">1</span>)]<br>        <span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> strs:  <span class="hljs-comment"># 遍历物品</span><br>            zeroNum = s.count(<span class="hljs-string">&#x27;0&#x27;</span>)  <span class="hljs-comment"># 统计 0 的个数</span><br>            oneNum = <span class="hljs-built_in">len</span>(s) - zeroNum  <span class="hljs-comment"># 统计 1 的个数</span><br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m, zeroNum - <span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):  <span class="hljs-comment"># 遍历背包容量，从后往前</span><br>                <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n, oneNum - <span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):<br>                    dp[i][j] = <span class="hljs-built_in">max</span>(dp[i][j], dp[i - zeroNum][j - oneNum] + <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> dp[m][n]<br></code></pre></td></tr></table></figure>
<h3 id="518-零钱兑换Ⅱ">518. 零钱兑换Ⅱ</h3>
<ol>
<li>
<p>确定 dp 数组以及下标的含义</p>
<p>定义二维 dp 数组 <code>dp[i][j]</code>：使用下标为 [0, i] 的 coins[i] 能够凑满 j 这么大容量的包，有 <code>dp[i][j]</code> 种组合方法。</p>
</li>
<li>
<p>确定递推公式</p>
<p>递推公式：<code>dp[i][j] = dp[i - 1][j] + dp[i][j - nums[i]]</code></p>
</li>
<li>
<p>dp 数组如何初始化</p>
<p><code>dp[i][0]</code> = 1</p>
</li>
<li>
<p>确定遍历顺序</p>
<p>二维 DP 数组的完全背包的两个 for 循环先后顺序是无所谓的。</p>
<p>先遍历背包，还是先遍历物品都是可以的。</p>
</li>
<li>
<p>打印 dp 数组</p>
<p>以 amount 为 5，coins 为：[2,3,5]</p>
<p>dp数组应该是这样的：</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span><span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">change</span>(<span class="hljs-params">self, amount, coins</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type amount: int</span><br><span class="hljs-string">        :type coins: List[int]</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        dp = [<span class="hljs-number">0</span>] * (amount + <span class="hljs-number">1</span>)<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br><br>        <span class="hljs-comment"># 遍历物品</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(coins)):<br>            <span class="hljs-comment"># 遍历背包</span><br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(coins[i], amount + <span class="hljs-number">1</span>):<br>                dp[j] += dp[j - coins[i]]<br>        <br>        <span class="hljs-keyword">return</span> dp[amount]<br></code></pre></td></tr></table></figure>
<h3 id="377-组合总和Ⅳ">377. 组合总和Ⅳ</h3>
<p>描述说是求组合，但元素相同顺序不同的组合算两个组合，<strong>其实就是求排列</strong>。</p>
<p>动规五部曲：</p>
<ol>
<li>
<p>确定 dp 数组以及下标的含义</p>
<p>dp[i]：凑成目标正整数为 i 的排列个数为 dp[i]</p>
</li>
<li>
<p>确定递推公式</p>
<p>递推公式：<code>dp[i] += dp[i - nums[j]]</code></p>
</li>
<li>
<p>dp 数组如何初始化</p>
<p>dp[0] = 1</p>
</li>
<li>
<p>确定遍历顺序</p>
<p>个数可以不限使用，说明这是一个完全背包。</p>
<p>得到的集合是排列，说明需要考虑元素之间的顺序。</p>
<p><strong>如果求组合数就是外层 for 循环遍历物品，内层 for 遍历背包</strong>。</p>
<p><strong>如果求排列数就是外层 for 遍历背包，内层 for 循环遍历物品</strong>。</p>
<p>最终遍历顺序：target（背包）放在外循环，将 nums（物品）放在内循环，内循环从前向后遍历。</p>
</li>
<li>
<p>举例推导 dp 数组</p>
<p>dp[0] = 1</p>
<p>dp[1] = dp[0] = 1</p>
<p>dp[2] = dp[1] + dp[0] = 2</p>
<p>dp[3] = dp[2] + dp[1] + dp[0] = 4</p>
<p>dp[4] = dp[3] + dp[2] + dp[1] = 7</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">combinationSum4</span>(<span class="hljs-params">self, nums, target</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type nums: List[int]</span><br><span class="hljs-string">        :type target: int</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        dp = [<span class="hljs-number">0</span>] * (target + <span class="hljs-number">1</span>)<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, target + <span class="hljs-number">1</span>):  <span class="hljs-comment"># 遍历背包</span><br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums)):  <span class="hljs-comment"># 遍历物品</span><br>               <span class="hljs-keyword">if</span> i - nums[j] &gt;= <span class="hljs-number">0</span>:<br>                dp[i] += dp[i - nums[j]]<br><br>        <span class="hljs-keyword">return</span> dp[target] <br></code></pre></td></tr></table></figure>
<h3 id="322-零钱兑换">322. 零钱兑换</h3>
<p>动规五部曲：</p>
<ol>
<li>
<p>确定 dp 数组以及下标的含义</p>
<p>dp[j]：凑足金额为 j 所需钱币的最少个数为 dp[j]</p>
</li>
<li>
<p>确定递推公式</p>
<p>dp[j] = min(dp[j - coins[i]] + 1, dp[j])</p>
</li>
<li>
<p>dp 数组如何初始化</p>
<p>dp[0] = 0</p>
</li>
<li>
<p>确定遍历顺序</p>
<p><strong>如果求组合数就是外层 for 循环遍历物品，内层 for 遍历背包</strong>。</p>
<p><strong>如果求排列数就是外层 for 遍历背包，内层 for 循环遍历物品</strong>。</p>
<p>本题的两个 for 循环的关系是：外层 for 循环遍历物品，内层 for 遍历背包或者外层 for 遍历背包，内层 for 循环遍历物品都是可以的。</p>
</li>
<li>
<p>举例推导 dp 数组</p>
<p>以输入：coin = [1, 2, 5] ，amount = 5 为例：</p>
<p>dp[i]：0 1 1 2 2 1</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">coinChange</span>(<span class="hljs-params">self, coins, amount</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type coins: List[int]</span><br><span class="hljs-string">        :type amount: int</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        dp = [<span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;inf&#x27;</span>)] * (amount + <span class="hljs-number">1</span>)  <span class="hljs-comment"># 创建数组，初始值为正无穷大</span><br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span><br><br>        <span class="hljs-keyword">for</span> coin <span class="hljs-keyword">in</span> coins:  <span class="hljs-comment"># 遍历硬币列表，相当于遍历物品</span><br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(coin, amount + <span class="hljs-number">1</span>):  <span class="hljs-comment"># 遍历背包容量</span><br>                <span class="hljs-keyword">if</span> dp[i - coin] != <span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;inf&#x27;</span>):  <span class="hljs-comment"># 进行状态转移</span><br>                    dp[i] = <span class="hljs-built_in">min</span>(dp[i - coin] + <span class="hljs-number">1</span>, dp[i])  <span class="hljs-comment"># 更新最小硬币数量</span><br><br>        <span class="hljs-keyword">if</span> dp[amount] == <span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;inf&#x27;</span>):<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> dp[amount]<br></code></pre></td></tr></table></figure>
<h3 id="279-完全平方数">279. 完全平方数</h3>
<p>动规五部曲：</p>
<ol>
<li>
<p>确定 dp 数组以及下标的含义</p>
<p>dp[j]：和为 j 的完全平方数的最少数量为 dp[j]</p>
</li>
<li>
<p>确定递推公式</p>
<p>dp[j] = min(dp[j - i * i] + 1, dp[j])</p>
</li>
<li>
<p>dp 数组如何初始化</p>
<p>dp[0] = 0</p>
</li>
<li>
<p>确定遍历顺序</p>
<p><strong>如果求组合数就是外层 for 循环遍历物品，内层 for 遍历背包</strong>。</p>
<p><strong>如果求排列数就是外层 for 遍历背包，内层 for 循环遍历物品</strong>。</p>
<p>本题的两个 for 循环的关系是：外层 for 循环遍历物品，内层 for 遍历背包或者外层 for 遍历背包，内层 for 循环遍历物品都是可以的。</p>
</li>
<li>
<p>举例推导 dp 数组</p>
</li>
</ol>
<p>​	输入 n = 5，</p>
<p>​	dp[i]：0 1 2 3 1 2</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">numSquares</span>(<span class="hljs-params">self, n</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type n: int</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        dp = [<span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;inf&#x27;</span>)] * (n + <span class="hljs-number">1</span>)<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span><br><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):  <span class="hljs-comment"># 遍历背包</span><br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">int</span>(i ** <span class="hljs-number">0.5</span> + <span class="hljs-number">1</span>)):  <span class="hljs-comment"># 遍历物品</span><br>                <span class="hljs-comment"># 更新凑成数字 i 所需的最少完全平方数数量</span><br>                dp[i] = <span class="hljs-built_in">min</span>(dp[i], dp[i - j * j] + <span class="hljs-number">1</span>)<br><br>        <span class="hljs-keyword">return</span> dp[n]<br></code></pre></td></tr></table></figure>
<h3 id="139-单词拆分">139. 单词拆分</h3>
<p>单词就是物品，字符串 s 就是背包，单词能否组成字符串 s，就是问物品能不能把背包装满。</p>
<p>拆分时可以重复使用字典中的单词，说明就是一个完全背包。</p>
<p>动规五部曲：</p>
<ol>
<li>
<p>确定 dp 数组以及下标的含义</p>
<p>dp[i]：字符串长度为 i 的话，dp[i] 为 true，表示可以拆分为一个或多个在字典中出现的单词。</p>
</li>
<li>
<p>确定递推公式</p>
<p>if([j, i] 这个区间的子串出现在字典里 &amp;&amp; dp[j]是true) 那么 dp[i] = true。</p>
</li>
<li>
<p>dp 数组如何初始化</p>
<p>dp[0] = true</p>
</li>
<li>
<p>确定遍历顺序</p>
<p>先遍历背包，再遍历物品。</p>
</li>
<li>
<p>举例推导 dp 数组</p>
<p>以输入：s = “leetcode”, wordDict = [“leet”, “code”]为例，dp 状态如图：</p>
<p>dp[i]：1 0 0 0 1 0 0 0 1</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">wordBreak</span>(<span class="hljs-params">self, s, wordDict</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type s: str</span><br><span class="hljs-string">        :type wordDict: List[str]</span><br><span class="hljs-string">        :rtype: bool</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        wordSet = <span class="hljs-built_in">set</span>(wordDict)<br>        n = <span class="hljs-built_in">len</span>(s)<br>        dp = [<span class="hljs-literal">False</span>] * (n + <span class="hljs-number">1</span>)  <span class="hljs-comment"># dp[i] 表示字符串的前 i 个字符是否可以被拆分成单词</span><br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-literal">True</span><br><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):  <span class="hljs-comment"># 遍历背包</span><br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i):  <span class="hljs-comment"># 遍历单词</span><br>                <span class="hljs-keyword">if</span> dp[j] <span class="hljs-keyword">and</span> s[j:i] <span class="hljs-keyword">in</span> wordSet:<br>                    <span class="hljs-comment"># 如果 s[0:j] 可以被拆分成单词，并且 s[j:i] 在单词集合中存在，则 s[0:i] 可以被拆分成单词</span><br>                    dp[i] = <span class="hljs-literal">True</span>  <br>                    <span class="hljs-keyword">break</span><br>        <span class="hljs-keyword">return</span> dp[n]<br></code></pre></td></tr></table></figure>
<h3 id="198-打家劫舍">198. 打家劫舍</h3>
<ol>
<li>
<p>确定 dp 数组以及下标的含义</p>
<p>dp[i]：考虑下标 i（包括 i）以内的房屋，最多可以偷窃的金额为 dp[i]。</p>
</li>
<li>
<p>确定递推公式</p>
<p>偷 i：dp[i] = dp[i - 2] + nums[i]</p>
<p>不偷 i：dp[i] = dp[i - 1]</p>
<p>递推公式：dp[i] = max(dp[i - 2] + nums[i], dp[i - 1])</p>
</li>
<li>
<p>dp 数组如何初始化</p>
<p>dp[0] = nums[0]</p>
<p>dp[1] = max(nums[0], nums[1])</p>
</li>
<li>
<p>确定遍历顺序</p>
<p>从前向后遍历。</p>
</li>
<li>
<p>举例推导 dp 数组</p>
<table>
<thead>
<tr>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
</tr>
</thead>
<tbody>
<tr>
<td>2</td>
<td>7</td>
<td>11</td>
<td>11</td>
<td>12</td>
</tr>
</tbody>
</table>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">rob</span>(<span class="hljs-params">self, nums</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type nums: List[int]</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">0</span>:  <span class="hljs-comment"># 如果没有房屋，返回0</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">1</span>:  <span class="hljs-comment"># 如果只有一个房屋，返回其金额</span><br>            <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>]<br><br>        <span class="hljs-comment"># 创建一个动态规划数组，用于存储最大金额</span><br>        dp = [<span class="hljs-number">0</span>] * <span class="hljs-built_in">len</span>(nums)<br>        dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>]<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(nums[<span class="hljs-number">0</span>], nums[<span class="hljs-number">1</span>])<br>        n = <span class="hljs-built_in">len</span>(nums)<br><br>        <span class="hljs-comment"># 遍历剩余的房屋</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>, n):<br>            <span class="hljs-comment"># 对于每个房屋，选择抢劫当前房屋和抢劫前一个房屋的最大金额</span><br>            dp[i] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">2</span>] + nums[i], dp[i - <span class="hljs-number">1</span>])<br><br>        <span class="hljs-keyword">return</span> dp[-<span class="hljs-number">1</span>]  <span class="hljs-comment"># 返回最后一个房屋中可抢劫的最大金额</span><br></code></pre></td></tr></table></figure>
<h3 id="213-打家劫舍Ⅱ">213. 打家劫舍Ⅱ</h3>
<p>对于一个数组，成环的话主要有如下三种情况：</p>
<ul>
<li>情况一：考虑不包含首尾元素</li>
<li>情况二：考虑包含首元素，不包含尾元素</li>
<li>情况三：考虑包含尾元素，不包含首元素</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">rob</span>(<span class="hljs-params">self, nums</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type nums: List[int]</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>]<br><br>        res1 = self.robRange(nums, <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">2</span>)  <span class="hljs-comment"># 情况二</span><br>        res2 = self.robRange(nums, <span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span>)  <span class="hljs-comment"># 情况三</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(res1, res2)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">robRange</span>(<span class="hljs-params">self, nums, start, end</span>):<br>        <span class="hljs-keyword">if</span> end == start:<br>            <span class="hljs-keyword">return</span> nums[start]<br><br>        pre_max = nums[start]<br>        cur_max = <span class="hljs-built_in">max</span>(nums[start], nums[start + <span class="hljs-number">1</span>])<br><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(start + <span class="hljs-number">2</span>, end + <span class="hljs-number">1</span>):<br>            temp = cur_max<br>            cur_max = <span class="hljs-built_in">max</span>(pre_max + nums[i], cur_max)<br>            pre_max = temp<br>    <br>        <span class="hljs-keyword">return</span> cur_max<br></code></pre></td></tr></table></figure>
<h3 id="337-打家劫舍Ⅲ">337. 打家劫舍Ⅲ</h3>
<p>对于树的话，首先想到遍历方式，前中后序（深度优先搜索）还是层序遍历（广度优先搜索）。</p>
<p><strong>本题一定要后序遍历，因为通过递归函数的返回值来做下一步计算</strong>。</p>
<p>如果抢了当前节点，两个孩子就不能动；如果没抢到当前节点，就可以考虑抢左右孩子。</p>
<ol>
<li>
<p>确定 dp 数组以及下标的含义</p>
<p>dp[i]：下标为 0 记录不偷该节点所得到的最大金钱，下标为 1 记录偷该节点所得到的最大金钱。</p>
</li>
<li>
<p>确定终止条件</p>
<p>在遍历的过程中，如果遇到空节点的话，无论偷还是不偷都是 0。</p>
<p>相当于 dp 数组的初始化。</p>
</li>
<li>
<p>确定遍历顺序</p>
<p>使用后序遍历。</p>
<p>通过递归左节点，得到左节点偷与不偷的金钱。</p>
<p>通过递归右节点，得到右节点偷与不偷的金钱。</p>
</li>
<li>
<p>确定单层递归的逻辑</p>
<p>如果偷当前节点，那么左右孩子不能偷。</p>
<p>如果不偷当前节点，那么左右孩子可以偷，选最大的。</p>
</li>
<li>
<p>举例推导 dp 数组</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Definition for a binary tree node.</span><br><span class="hljs-comment"># class TreeNode(object):</span><br><span class="hljs-comment">#     def __init__(self, val=0, left=None, right=None):</span><br><span class="hljs-comment">#         self.val = val</span><br><span class="hljs-comment">#         self.left = left</span><br><span class="hljs-comment">#         self.right = right</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">rob</span>(<span class="hljs-params">self, root</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type root: Optional[TreeNode]</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        dp = self.traversal(root)<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(dp)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">traversal</span>(<span class="hljs-params">self, node</span>):<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> node:<br>            <span class="hljs-keyword">return</span> (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<br><br>        left = self.traversal(node.left)<br>        right = self.traversal(node.right)<br><br>        <span class="hljs-comment"># 不偷当前节点，偷子节点</span><br>        val0 = <span class="hljs-built_in">max</span>(left[<span class="hljs-number">0</span>], left[<span class="hljs-number">1</span>]) + <span class="hljs-built_in">max</span>(right[<span class="hljs-number">0</span>], right[<span class="hljs-number">1</span>])<br><br>        <span class="hljs-comment"># 偷当前节点，不偷子节点</span><br>        val1 = node.val + left[<span class="hljs-number">0</span>] + right[<span class="hljs-number">0</span>]<br><br>        <span class="hljs-keyword">return</span> (val0, val1)<br></code></pre></td></tr></table></figure>
<h3 id="121-买卖股票的最佳时机">121. 买卖股票的最佳时机</h3>
<p>动规五部曲：</p>
<ol>
<li>
<p>确定 dp 数组以及下标的含义</p>
<p><code>dp[i][0]</code> 表示第 i 天持有股票所得最多现金。</p>
<p><code>dp[i][1]</code> 表示第 i 天不持有股票所得最多现金。</p>
</li>
<li>
<p>确定递推公式</p>
<p>如果第 i 天持有股票：</p>
<ul>
<li>第 i - 1 天就持有股票，<code>dp[i - 1][0]</code></li>
<li>第 i 天买入股票，<code>-price[i]</code></li>
</ul>
<p>那么 <code>dp[i][0]</code> 应该选所得现金最大的，所以 <code>dp[i][0] = max(dp[i - 1][0], -prices[i])</code></p>
<p>如果第 i 天不持有股票：</p>
<ul>
<li>第 i - 1 天不持有股票，<code>dp[i - 1][1]</code></li>
<li>第 i 天卖出股票，<code>prices[i] + dp[i - 1][0]</code></li>
</ul>
<p>同样 <code>dp[i][1]</code> 取最大的，<code>dp[i][1] = max(dp[i - 1][1], prices[i] + dp[i - 1][0])</code></p>
</li>
<li>
<p>dp 数组如何初始化</p>
<p><code>dp[0][0] = -price[0]</code></p>
<p><code>dp[0][1] = 0</code></p>
</li>
<li>
<p>确定遍历顺序</p>
<p>dp[i] 都是由 dp[i - 1] 遍历出来的，那么一定是从前向后遍历。</p>
</li>
<li>
<p>举例推导 dp 数组</p>
<p>输入：[7, 1, 5, 3, 6, 4]</p>
<p>0 0 4 4 4 5 5</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">maxProfit</span>(<span class="hljs-params">self, prices</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type prices: List[int]</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        n = <span class="hljs-built_in">len</span>(prices)<br>        <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br><br>        dp = [[<span class="hljs-number">0</span>] * <span class="hljs-number">2</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = - prices[<span class="hljs-number">0</span>]<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">0</span><br><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n):<br>            dp[i][<span class="hljs-number">0</span>] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>], - prices[i])<br>            dp[i][<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>], prices[i] + dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>])<br><br>        <span class="hljs-keyword">return</span> dp[-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure>
<h3 id="122-买卖股票的最佳时机Ⅱ-2">122. 买卖股票的最佳时机Ⅱ</h3>
<p>和上一题唯一不同的地方，就是推导 <code>dp[i][0]</code> 时，第 i 天买入股票的情况。</p>
<p>因为一只股票可以买卖多次，所以当第 i 天买入股票的时候，所持有的现金可能有之前买卖过的利润。</p>
<p>第 i 天持有股票即 <code>dp[i][0]</code> ，如果是第 i 天买入股票，所得现金就是昨天不持有股票得所的现金减去今天得股票价格即：<code>dp[i - 1][1] - prices[i]</code>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">maxProfit</span>(<span class="hljs-params">self, prices</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type prices: List[int]</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        n = <span class="hljs-built_in">len</span>(prices)<br>        <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        <br>        dp = [[<span class="hljs-number">0</span>] * <span class="hljs-number">2</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = - prices[<span class="hljs-number">0</span>]<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">0</span><br><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n):<br>            dp[i][<span class="hljs-number">0</span>] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>] - prices[i])<br>            dp[i][<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>], prices[i] + dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>])<br>        <br>        <span class="hljs-keyword">return</span> dp[-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure>
<h3 id="123-买卖股票的最佳时机Ⅲ">123. 买卖股票的最佳时机Ⅲ</h3>
<p>动规五部曲：</p>
<ol>
<li>
<p>确定 dp 数组以及下标的含义</p>
<p>一天一共有五个状态：</p>
<ol start="0">
<li>没有操作</li>
<li>第一次持有股票</li>
<li>第一次不持有股票</li>
<li>第二次持有股票</li>
<li>第二次不持有股票</li>
</ol>
<p><code>dp[i][j]</code> 中 i 表示第 i 天，j 为 [0 - 4] 五个状态，<code>dp[i][j]</code> 表示第 i 天状态 j 所剩最大现金。</p>
<p>注意：<strong><code>dp[i][1]</code> 表示得是第 i 天，买入股票的状态，并不是说一定要第 i 天买入股票。</strong></p>
</li>
<li>
<p>确定递推公式</p>
<p><code>dp[i][1] = max(dp[i - 1][0] - prices[i], dp[i - 1][1])</code></p>
<p><code>dp[i][2] = max(dp[i - 1][1] + prices[i], dp[i - 1][2])</code></p>
<p><code>dp[i][3] = max(dp[i - 1][2] - prices[i], dp[i - 1][3])</code></p>
<p><code>dp[i][4] = max(dp[i - 1][3] + prices[i], dp[i - 1][4])</code></p>
</li>
<li>
<p>dp 数组如何初始化</p>
<p><code>dp[0][0] = 0</code></p>
<p><code>dp[0][1] = - prices[0]</code></p>
<p><code>dp[0][2] = 0</code></p>
<p><code>dp[0][3] = - prices[0]</code></p>
<p><code>dp[0][4] = 0</code></p>
</li>
<li>
<p>确定遍历顺序</p>
<p>一定是从前向后遍历</p>
</li>
<li>
<p>举例推导 dp 数组</p>
<table>
<thead>
<tr>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>-1</td>
<td>0</td>
<td>-1</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>-1</td>
<td>1</td>
<td>-1</td>
<td>1</td>
</tr>
<tr>
<td>0</td>
<td>-1</td>
<td>2</td>
<td>-1</td>
<td>2</td>
</tr>
<tr>
<td>0</td>
<td>-1</td>
<td>3</td>
<td>-1</td>
<td>3</td>
</tr>
<tr>
<td>0</td>
<td>-1</td>
<td>4</td>
<td>-1</td>
<td>4</td>
</tr>
</tbody>
</table>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">maxProfit</span>(<span class="hljs-params">self, prices</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type prices: List[int]</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        n = <span class="hljs-built_in">len</span>(prices)<br>        <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br><br>        dp = [[<span class="hljs-number">0</span>] * <span class="hljs-number">5</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = - prices[<span class="hljs-number">0</span>]<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">3</span>] = - prices[<span class="hljs-number">0</span>]<br><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n):<br>            dp[i][<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] - prices[i], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>])<br>            dp[i][<span class="hljs-number">2</span>] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>] + prices[i], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">2</span>])<br>            dp[i][<span class="hljs-number">3</span>] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">2</span>] - prices[i], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">3</span>])<br>            dp[i][<span class="hljs-number">4</span>] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">3</span>] + prices[i], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">4</span>])<br><br>        <span class="hljs-keyword">return</span> dp[-<span class="hljs-number">1</span>][<span class="hljs-number">4</span>]<br></code></pre></td></tr></table></figure>
<h3 id="188-买卖股票的最佳时机Ⅳ">188. 买卖股票的最佳时机Ⅳ</h3>
<p>动规五部曲：</p>
<ol>
<li>
<p>确定 dp 数组以及下标的含义</p>
<p>使用二维数组 <code>dp[i][j]</code>：第 i 天的状态为 j，所剩下的最大现金是 <code>dp[i][j]</code>。</p>
<p>至多有 K 笔交易，那么 j 的范围就定义为 2 * k + 1 即可。</p>
</li>
<li>
<p>确定递推公式</p>
<p><code>dp[i][1]</code></p>
<ul>
<li>操作一：第 i 天买入股票，<code>dp[i][1] = dp[i - 1][0] - prices[i]</code></li>
<li>操作二：第 i 天没有操作，沿用前一天买入的状态，<code>dp[i][1] = dp[i - 1][1]</code></li>
</ul>
<p>递推公式：<code>dp[i][1] = max(dp[i - 1][0] - prices[i], dp[i - 1][1])</code></p>
<p><code>dp[i][2]</code></p>
<ul>
<li>操作一：第 i 天卖出股票，<code>dp[i][2] = dp[i - 1][1] + prices[i]</code></li>
<li>操作二：第 i 天没有操作，沿用前一天卖出的状态，<code>dp[i][2] = dp[i - 1][2]</code></li>
</ul>
<p>递推公式：<code>dp[i][2] = max(dp[i - 1][1] + prices[i], dp[i - 1][2])</code></p>
</li>
<li>
<p>dp 数组如何初始化</p>
<p><code>dp[0][0] = 0</code></p>
<p><code>dp[0][1] = - prices[0]</code></p>
<p><code>dp[0][3] = - prices[0]</code></p>
<p><code>dp[0][4] = 0</code></p>
<p><strong>同理，可以推出 <code>dp[0][j] 当 j 为奇数的时候都初始化为 -prices[0]</code></strong></p>
</li>
<li>
<p>确定遍历顺序</p>
<p>从前向后遍历</p>
</li>
<li>
<p>举例推导 dp 数组</p>
<table>
<thead>
<tr>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>-1</td>
<td>0</td>
<td>-1</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>-1</td>
<td>1</td>
<td>-1</td>
<td>1</td>
</tr>
<tr>
<td>0</td>
<td>-1</td>
<td>2</td>
<td>-1</td>
<td>2</td>
</tr>
<tr>
<td>0</td>
<td>-1</td>
<td>3</td>
<td>-1</td>
<td>3</td>
</tr>
<tr>
<td>0</td>
<td>-1</td>
<td>4</td>
<td>-1</td>
<td>4</td>
</tr>
</tbody>
</table>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">maxProfit</span>(<span class="hljs-params">self, k, prices</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type k: int</span><br><span class="hljs-string">        :type prices: List[int]</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        n = <span class="hljs-built_in">len</span>(prices)<br>        <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        <br>        dp = [[<span class="hljs-number">0</span>] * (<span class="hljs-number">2</span> * k + <span class="hljs-number">1</span>) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]<br>        <br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span> * k, <span class="hljs-number">2</span>):<br>            dp[<span class="hljs-number">0</span>][j] = -prices[<span class="hljs-number">0</span>]<br><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-number">2</span> * k - <span class="hljs-number">1</span>, <span class="hljs-number">2</span>):<br>                dp[i][j + <span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][j] - prices[i], dp[i - <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>])<br>                dp[i][j + <span class="hljs-number">2</span>] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>] + prices[i], dp[i - <span class="hljs-number">1</span>][j + <span class="hljs-number">2</span>])<br><br>        <span class="hljs-keyword">return</span> dp[-<span class="hljs-number">1</span>][<span class="hljs-number">2</span> * k]<br></code></pre></td></tr></table></figure>
<h3 id="309-买卖股票的最佳时机含冷冻期">309. 买卖股票的最佳时机含冷冻期</h3>
<ol>
<li>
<p>确定 dp 数组以及下标的含义</p>
<p><code>dp[i][j]</code>，第 i 天状态为 j，所剩的最多现金为 <code>dp[i][j]</code>。</p>
<ul>
<li>状态一：持有股票</li>
<li>不持有股票：
<ul>
<li>状态二：保持卖出股票的状态（两天前卖出股票，度过一天冷冻期。或者前一天卖出股票状态，一直没操作）</li>
<li>状态三：今天卖出股票</li>
</ul>
</li>
<li>状态四：今天为冷冻期，但冷冻期不可持续，只有一天</li>
</ul>
</li>
<li>
<p>确定递推公式</p>
<p>达到买入股票的状态（状态一），即 <code>dp[i][0]</code>：</p>
<ul>
<li>操作一：前一天持有股票（状态一），<code>dp[i][0] = dp[i - 1][0]</code></li>
<li>操作二：
<ul>
<li>前一天是冷冻期（状态四），<code>dp[i - 1][3] - prices[i]</code></li>
<li>前一天是卖出股票（状态二），<code>dp[i - 1][1] - prices[i]</code></li>
</ul>
</li>
</ul>
<p><code>dp[i][0] = max(dp[i - 1][0], dp[i - 1][3] - prices[i])</code></p>
<p>达到保持卖出股票状态（状态二），即 <code>dp[i][1]</code>：</p>
<ul>
<li>操作一：前一天就是状态二</li>
<li>操作二：前一天是冷冻期</li>
</ul>
<p><code>dp[i][1] = max(dp[i - 1][1], dp[i - 1][3])</code></p>
<p>达到今天就卖出股票状态（状态三），即 <code>dp[i][2]</code>：</p>
<p>昨天一定持有股票，今天买出</p>
<p><code>dp[i][2] = dp[i - 1][0] + prices[i]</code></p>
<p>达到冷冻期状态（状态四），即 <code>dp[i][3]</code>：</p>
<p>昨天卖出了股票</p>
<p><code>dp[i][3] = dp[i - 1][2]</code></p>
</li>
<li>
<p>dp 数组如何初始化</p>
<p><code>dp[0][0] = -prices[0]</code></p>
<p><code>dp[0][1] = 0</code></p>
<p><code>dp[0][2] = 0</code></p>
<p><code>dp[0][3] = 0</code></p>
</li>
<li>
<p>确定遍历顺序</p>
<p>从前向后遍历</p>
</li>
<li>
<p>举例推导 dp 数组</p>
<table>
<thead>
<tr>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
</tr>
</thead>
<tbody>
<tr>
<td>-1</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>-1</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>-1</td>
<td>0</td>
<td>2</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>-1</td>
<td>2</td>
</tr>
<tr>
<td>1</td>
<td>2</td>
<td>3</td>
<td>-1</td>
</tr>
</tbody>
</table>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">maxProfit</span>(<span class="hljs-params">self, prices</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type prices: List[int]</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        n = <span class="hljs-built_in">len</span>(prices)<br>        <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br> <br>        dp = [[<span class="hljs-number">0</span>] * <span class="hljs-number">4</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = -prices[<span class="hljs-number">0</span>]<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n):<br>            dp[i][<span class="hljs-number">0</span>] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>], <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">3</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>]) - prices[i])<br>            dp[i][<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">3</span>])<br>            dp[i][<span class="hljs-number">2</span>] = dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] + prices[i]<br>            dp[i][<span class="hljs-number">3</span>] = dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">2</span>]<br>        <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(dp[n - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>], dp[n - <span class="hljs-number">1</span>][<span class="hljs-number">2</span>], dp[n - <span class="hljs-number">1</span>][<span class="hljs-number">3</span>])<br></code></pre></td></tr></table></figure>
<h3 id="714-买卖股票的最佳时机含手续费">714. 买卖股票的最佳时机含手续费</h3>
<ol>
<li>
<p>确定 dp 数组以及下标含义</p>
<p><code>dp[i][0]</code> 表示第 i 天持有股票所得最多现金。<code>dp[i][1]</code> 表示第 i 天不持有股票所得最多现金。</p>
</li>
<li>
<p>确定递推公式</p>
<p>如果第 i 天持有股票即 <code>dp[i][0]</code></p>
<ul>
<li>第 i - 1 天持有股票，保持现状，所得现金就是昨天持有股票的所得现金，<code>dp[i - 1][0]</code>。</li>
<li>第 i 天买入股票，所得现金就是昨天不持有股票的所得现金减去今天股票价格，<code>dp[i - 1][1] - prices[i]</code>。</li>
</ul>
<p><code>dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] - prices[i])</code></p>
<p>如果第 i 天不持有股票即 <code>dp[i][1]</code></p>
<ul>
<li>第 i - 1天不持有股票，保持现状，所得现金就是昨天不持有股票得所得现金，<code>dp[i - 1][1]</code>。</li>
<li>第 i 天卖出股票，所得现金就是按照今天股票价格卖出后所得现金，<strong>需要计算手续费</strong>，<code>dp[i - 1][0] + prices[i] - fee</code>。</li>
</ul>
<p><code>dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + prices[i] - fee)</code></p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">maxProfit</span>(<span class="hljs-params">self, prices, fee</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type prices: List[int]</span><br><span class="hljs-string">        :type fee: int</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        n = <span class="hljs-built_in">len</span>(prices)<br>        dp = [[<span class="hljs-number">0</span>] * <span class="hljs-number">2</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = -prices[<span class="hljs-number">0</span>]<br><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n):<br>            dp[i][<span class="hljs-number">0</span>] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>] - prices[i])<br>            dp[i][<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] + prices[i] - fee)<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(dp[-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>], dp[-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>])<br></code></pre></td></tr></table></figure>
<h3 id="300-最长递增子序列">300. 最长递增子序列</h3>
<p>动规五部曲：</p>
<ol>
<li>
<p>dp[i] 的定义</p>
<p><strong>dp[i] 表示 i 之前包括 i 的以 nums[i] 结尾的最长递归子序列的长度</strong></p>
</li>
<li>
<p>状态转移方程</p>
<p>if (nums[i] &gt; nums[j]):</p>
<p>​	dp[i] = max(dp[i], dp[j] + 1)</p>
<p><strong>这里不是要 dp[i] 与 dp[j] + 1 进行比较，而是要取 dp[j] + 1 的最大值。</strong></p>
</li>
<li>
<p>dp[i] 的初始化</p>
<p>每一个 i，对应的 dp[i]（即最长递增子序列）起始大小至少都是 1。</p>
</li>
<li>
<p>确定遍历顺序</p>
<p>从前往后遍历</p>
</li>
<li>
<p>举例推导 dp 数组</p>
<table>
<thead>
<tr>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>2</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>2</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>2</td>
<td>1</td>
<td>3</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>2</td>
<td>1</td>
<td>3</td>
<td>3</td>
</tr>
</tbody>
</table>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">lengthOfLIS</span>(<span class="hljs-params">self, nums</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type nums: List[int]</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        n = <span class="hljs-built_in">len</span>(nums)<br>        <span class="hljs-keyword">if</span> n &lt;= <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">return</span> n<br>        dp = [<span class="hljs-number">1</span>] * n<br>        res = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, i):<br>                <span class="hljs-keyword">if</span> nums[i] &gt; nums[j]:<br>                    dp[i] = <span class="hljs-built_in">max</span>(dp[i], dp[j] + <span class="hljs-number">1</span>)<br>            res = <span class="hljs-built_in">max</span>(res, dp[i])  <span class="hljs-comment"># 取最长的子序列</span><br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure>
<h3 id="674-最长连续递增序列">674. 最长连续递增序列</h3>
<p>动规五部曲：</p>
<ol>
<li>
<p>确定 dp 数组以及下标的含义</p>
<p><strong>dp[i]：以下标 i 为结尾的连续递增的子序列长度为 dp[i]。</strong></p>
</li>
<li>
<p>确定递推公式</p>
<p>如果 nums[i] &gt; nums[i - 1]，那么以 i 为结尾的连续递增子序列长度一定等于以 i - 1 为结尾的连续递增子序列长度 + 1。</p>
<p>递推公式：dp[i] = dp[i - 1] + 1</p>
</li>
<li>
<p>dp 数组如何初始化</p>
<p>dp[i] = 1</p>
</li>
<li>
<p>确定遍历顺序</p>
<p>从前向后遍历</p>
</li>
<li>
<p>举例推导 dp 数组</p>
<p>0 1 2 3 4</p>
<p>1 2 3 1 2</p>
<p>取 dp[i] 里的最大值，所以 dp[2] 才是结果。</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">findLengthOfLCIS</span>(<span class="hljs-params">self, nums</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type nums: List[int]</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> nums:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br><br>        max_len = <span class="hljs-number">1</span><br>        cur_len = <span class="hljs-number">1</span><br><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(nums)):<br>            <span class="hljs-keyword">if</span> nums[i] &gt; nums[i - <span class="hljs-number">1</span>]:<br>                cur_len += <span class="hljs-number">1</span><br>                max_len = <span class="hljs-built_in">max</span>(max_len, cur_len)<br>            <span class="hljs-keyword">else</span>:<br>                cur_len = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> max_len<br></code></pre></td></tr></table></figure>
<h3 id="718-最长重复子数组">718. 最长重复子数组</h3>
<p>用二维数组可以记录两个字符串的所有比较情况。</p>
<ol>
<li>
<p>确定 dp 数组以及下标的含义</p>
<p><code>dp[i][j]</code>：以下标为 i - 1 为结尾的 A，以下标为 j - 1 为结尾的 B，最长重复子数组长度为 <code>dp[i][j]</code>。</p>
<p><code>dp[i][j]</code> 的定义也就决定了遍历 <code>dp[i][j]</code> 的时候 i 和 j 都要从 1 开始。</p>
</li>
<li>
<p>确定递推公式：</p>
<p>根据 <code>dp[i][j]</code> 的定义，<code>dp[i][j]</code> 的状态只能由 <code>dp[i - 1][j - 1]</code> 推导出来。</p>
<p>当 A[i - 1] 和 B[j - 1] 相等的时候，<code>dp[i][j] = dp[i - 1][j - 1] + 1</code></p>
</li>
<li>
<p>dp 数组如何初始化</p>
<p><code>dp[i][0]</code> 和 <code>dp[0][j]</code> 初始化为 0。</p>
</li>
<li>
<p>确定遍历顺序</p>
<p>外层 for 循环遍历 A，内层 for 循环遍历 B。</p>
</li>
<li>
<p>举例推导 dp 数组</p>
<p>输入：A[1, 2, 3, 2, 1]  B[3, 2, 1, 4, 7]</p>
<p>最大长度为 3</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">findLength</span>(<span class="hljs-params">self, nums1, nums2</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type nums1: List[int]</span><br><span class="hljs-string">        :type nums2: List[int]</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-comment"># 创建二维数组 dp</span><br>        dp = [[<span class="hljs-number">0</span>] * (<span class="hljs-built_in">len</span>(nums2) + <span class="hljs-number">1</span>) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums1) + <span class="hljs-number">1</span>)]<br>        <span class="hljs-comment"># 记录最长公共子数组的长度</span><br>        res = <span class="hljs-number">0</span><br><br>        <span class="hljs-comment"># 遍历数组 nums1</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(nums1) + <span class="hljs-number">1</span>):<br>            <span class="hljs-comment"># 遍历数组 nums2</span><br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(nums2) + <span class="hljs-number">1</span>):<br>                <span class="hljs-keyword">if</span> nums1[i - <span class="hljs-number">1</span>] == nums2[j - <span class="hljs-number">1</span>]:<br>                    <span class="hljs-comment"># 在当前位置上的最长公共子数组的长度为前一个位置上的长度 + 1</span><br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span><br>                <span class="hljs-comment"># 更新最长公共子数组的长度</span><br>                <span class="hljs-keyword">if</span> dp[i][j] &gt; res:<br>                    res = dp[i][j]<br><br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure>
<h3 id="1143-最长公共子序列">1143. 最长公共子序列</h3>
<ol>
<li>
<p>确定 dp 数组以及下标的含义：</p>
<p><code>dp[i][j]</code>：长度为 <code>[0, i - 1]</code> 的字符串 text1 与长度为 <code>[0, j - 1]</code> 的字符串 text2 的最长公共子序列为 <code>dp[i][j]</code>。</p>
</li>
<li>
<p>确定递推公式</p>
<p><code>dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])</code></p>
</li>
<li>
<p>dp 数组如何初始化</p>
<p><code>dp[i][0] = 0</code></p>
<p><code>dp[0][j] = 0</code></p>
</li>
<li>
<p>确定遍历顺序</p>
<p>从前往后，从上到下遍历这个矩阵</p>
</li>
<li>
<p>举例推导 dp 数组</p>
<p>输入：text1 = “abcde”，text2 = “ace”</p>
<p>0 0 0 0</p>
<p>0 1 1 1</p>
<p>0 1 1 1</p>
<p>0 1 2 2</p>
<p>0 1 2 2</p>
<p>0 1 2 3</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">longestCommonSubsequence</span>(<span class="hljs-params">self, text1, text2</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type text1: str</span><br><span class="hljs-string">        :type text2: str</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-comment"># 创建一个二维数组 dp, 用于存储最长公共子序列的长度</span><br>        dp = [[<span class="hljs-number">0</span>] * (<span class="hljs-built_in">len</span>(text2) + <span class="hljs-number">1</span>) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(text1) + <span class="hljs-number">1</span>)]<br><br>        <span class="hljs-comment"># 遍历 text1 和 text2，填充 dp 数组</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(text1) + <span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(text2) + <span class="hljs-number">1</span>):<br>                <span class="hljs-keyword">if</span> text1[i - <span class="hljs-number">1</span>] == text2[j - <span class="hljs-number">1</span>]:<br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span><br>                <span class="hljs-keyword">else</span>:<br>                    dp[i][j] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>])<br>        <br>        <span class="hljs-comment"># 返回最长公共子序列的长度</span><br>        <span class="hljs-keyword">return</span> dp[<span class="hljs-built_in">len</span>(text1)][<span class="hljs-built_in">len</span>(text2)]<br></code></pre></td></tr></table></figure>
<h3 id="1035-不相交的线">1035. 不相交的线</h3>
<p>绘制一些连接两个数字 nums1[i] 和 nums2[j] 的直线，只要 nums1[i] == nums2[j]，且直线不能相交。</p>
<p>直线不能相交，就是说在字符串 nums1 中找到一个字符串 nums2 相同的子序列，且这个子序列不能改变相对顺序，只要相对顺序不改变，连接相同数字的直线就不会相交。</p>
<p><strong>本题说是求绘制的最大连接数，其实就是求两个字符串的最长公共子序列的长度。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">maxUncrossedLines</span>(<span class="hljs-params">self, nums1, nums2</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type nums1: List[int]</span><br><span class="hljs-string">        :type nums2: List[int]</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-comment"># 创建一个二维数组 dp, 用于存储最长公共子序列的长度</span><br>        dp = [[<span class="hljs-number">0</span>] * (<span class="hljs-built_in">len</span>(nums2) + <span class="hljs-number">1</span>) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums1) + <span class="hljs-number">1</span>)]<br><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(nums1) + <span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(nums2) + <span class="hljs-number">1</span>):<br>                <span class="hljs-keyword">if</span> nums1[i - <span class="hljs-number">1</span>] == nums2[j - <span class="hljs-number">1</span>]:<br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span><br>                <span class="hljs-keyword">else</span>:<br>                    dp[i][j] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>])<br>        <span class="hljs-keyword">return</span> dp[<span class="hljs-built_in">len</span>(nums1)][<span class="hljs-built_in">len</span>(nums2)]<br></code></pre></td></tr></table></figure>
<h3 id="53-最大子序和-2">53. 最大子序和</h3>
<p>动规五部曲：</p>
<ol>
<li>
<p>确定 dp 数组以及下标的含义</p>
<p>dp[i]：包括下标 i 的最大连续子序列和为 dp[i]。</p>
</li>
<li>
<p>确定递推公式</p>
<p>dp[i] 只有两个方向可以推导：</p>
<ul>
<li>dp[i - 1] + nums[i]，即 nums[i] 加入当前连续子序列和。</li>
<li>nums[i]，即从头开始计算当前连续子序列和。</li>
</ul>
<p>递推公式：dp[i] = max(dp[i - 1] + nums[i], nums[i])</p>
</li>
<li>
<p>dp 数组如何初始化</p>
<p>dp[0] = nums[0]</p>
</li>
<li>
<p>确定遍历顺序</p>
<p>从前向后遍历</p>
</li>
<li>
<p>举例推导 dp 数组</p>
<p>输入：[-2, 1, -3, 4, -1, 2, 1, -5, 4]</p>
<table>
<thead>
<tr>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
</tr>
</thead>
<tbody>
<tr>
<td>-2</td>
<td>1</td>
<td>-2</td>
<td>4</td>
<td>3</td>
<td>5</td>
<td>6</td>
<td>1</td>
<td>5</td>
</tr>
</tbody>
</table>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">maxSubArray</span>(<span class="hljs-params">self, nums</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type nums: List[int]</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        dp = [<span class="hljs-number">0</span>] * <span class="hljs-built_in">len</span>(nums)<br>        dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>]<br>        res = dp[<span class="hljs-number">0</span>]<br><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(nums)):<br>            <span class="hljs-comment"># 递推公式</span><br>            dp[i] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>] + nums[i], nums[i])<br>            res = <span class="hljs-built_in">max</span>(res, dp[i])<br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure>
<h3 id="392-判断子序列">392. 判断子序列</h3>
<p>根据题意可以发现，只需要计算删除的情况，不用考虑增加和替换的情况。</p>
<ol>
<li>
<p>确定 dp 数组以及下标的含义</p>
<p><code>dp[i][j]</code>：表示以下标 i - 1 为结尾的字符换 s，和以下标 j - 1 为结尾的字符串 t，相同子序列的长度为 <code>dp[i][j]</code>。</p>
</li>
<li>
<p>确定递推公式</p>
<ul>
<li>
<p>if (s[i - 1] == t[j - 1])</p>
<ul>
<li>t 中找到了一个字符在 s 中也出现了</li>
</ul>
</li>
<li>
<p>if (s[i - 1] != t[j - 1])</p>
<ul>
<li>相当于 t 要删除元素，继续匹配</li>
</ul>
</li>
</ul>
</li>
<li>
<p>dp 数组初始化</p>
<p><code>dp[i][j]</code> 都是依赖于 <code>dp[i - 1][j - 1]</code> 和 <code>dp[i][j - 1]</code>，需要初始化。</p>
</li>
<li>
<p>确定遍历顺序</p>
<p>从上到下，从左到右</p>
</li>
<li>
<p>举例推导 dp 数组</p>
<p>输入 s = “abc”，t = “ahbgdc”</p>
<table>
<thead>
<tr>
<th></th>
<th>a</th>
<th>h</th>
<th>b</th>
<th>g</th>
<th>d</th>
<th>c</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>2</td>
<td>2</td>
<td>2</td>
<td>2</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>3</td>
</tr>
</tbody>
</table>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">isSubsequence</span>(<span class="hljs-params">self, s, t</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type s: str</span><br><span class="hljs-string">        :type t: str</span><br><span class="hljs-string">        :rtype: bool</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        dp = [[<span class="hljs-number">0</span>] * (<span class="hljs-built_in">len</span>(t) + <span class="hljs-number">1</span>) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(s) + <span class="hljs-number">1</span>)]<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(s) + <span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(t) + <span class="hljs-number">1</span>):<br>                <span class="hljs-keyword">if</span> s[i - <span class="hljs-number">1</span>] == t[j - <span class="hljs-number">1</span>]:<br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span><br>                <span class="hljs-keyword">else</span>:<br>                    dp[i][j] = dp[i][j - <span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">if</span> dp[-<span class="hljs-number">1</span>][-<span class="hljs-number">1</span>] == <span class="hljs-built_in">len</span>(s):<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure>
<h3 id="115-不同的子序列">115. 不同的子序列</h3>
<p>只有删除操作，不用考虑替换增加。</p>
<p>动规五部曲：</p>
<ol>
<li>
<p>确定 dp 数组以及下标的含义</p>
<p><code>dp[i][j]</code>：以 i - 1 为结尾的 s 子序列中出现以 j - 1 为结尾的 t 的个数为 <code>dp[i][j]</code>。</p>
</li>
<li>
<p>确定递推公式</p>
<p>基本要分析两种情况：</p>
<ul>
<li>s[i - 1] 与 t[j - 1] 相等</li>
<li>s[i - 1] 与 t[j - 1] 不相等</li>
</ul>
<p>当s[i - 1] 与 t[j - 1] 相等时，<code>dp[i][j]</code> 可以有两部分组成。</p>
<p>一部分用 s[i - 1] 来匹配，个数为 <code>dp[i - 1][j - 1]</code>。即不需要考虑当前 s 字串和 t 字串的最后一位字母，所以只需要 <code>dp[i - 1][j - 1]</code>。</p>
<p>另一部分是不用 s[i - 1] 来匹配，个数为 <code>dp[i - 1][j]</code>。</p>
<p>递推公式为：<code>dp[i][j] = dp[i - 1][j]</code>。</p>
</li>
<li>
<p>dp 数组如何初始化</p>
<p><code>dp[0][j] = 0</code></p>
<p><code>dp[0][0] = 1</code></p>
</li>
<li>
<p>确定遍历顺序</p>
<p>从上到下，从左到右</p>
</li>
<li>
<p>距离推导 dp 数组</p>
<p>s：“baegg”，t：“bag” 为例，推导 dp 数组状态</p>
<p>​        b  a  g</p>
<p>​    1  0  0  0</p>
<p>b  1  1  0  0</p>
<p>a  1  1  1  0</p>
<p>e  1  1  1  0</p>
<p>g  1  1  1  1</p>
<p>g  1  1  1  2</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">numDistinct</span>(<span class="hljs-params">self, s, t</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type s: str</span><br><span class="hljs-string">        :type t: str</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        dp = [[<span class="hljs-number">0</span>] * (<span class="hljs-built_in">len</span>(t) + <span class="hljs-number">1</span>) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(s) + <span class="hljs-number">1</span>)]<br><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(s)):<br>            dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(t)):<br>            dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(s) + <span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(t) + <span class="hljs-number">1</span>):<br>                <span class="hljs-keyword">if</span> s[i - <span class="hljs-number">1</span>] == t[j - <span class="hljs-number">1</span>]:<br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">1</span>][j]<br>                <span class="hljs-keyword">else</span>: <br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j]<br>        <span class="hljs-keyword">return</span> dp[-<span class="hljs-number">1</span>][-<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure>
<h3 id="583-两个字符串的删除操作">583. 两个字符串的删除操作</h3>
<p>两个字符串可以相互删除。</p>
<ol>
<li>
<p>确定 dp 数组以及下标的含义</p>
<p><code>dp[i][j]</code>：以 i - 1 为结尾的字符串 word1，和以  j - 1 为结尾的字符串 word2。想要达到相等，所需要删除元素的最少次数。</p>
</li>
<li>
<p>确定递推公式</p>
<ul>
<li>当 word1[i - 1] 与 word2[j - 1] 相同的时候</li>
<li>当 word1[i - 1] 与 word2[j - 1] 不相同的时候</li>
</ul>
<p>当 word1[i - 1] 与 word2[j - 1] 相同的时候，<code>dp[i][j] = dp[i - 1][j - 1]</code></p>
<p>当 word1[i - 1] 与 word2[j - 1] 不相同的时候，有三种情况：</p>
<ul>
<li>删 word1[i - 1]，最少操作次数为 <code>dp[i - 1][j] + 1</code></li>
<li>删 word2[j - 1]，最少操作次数为 <code>dp[i][j - 1] + 1</code></li>
<li>同时删 word1[i - 1] 和 word2[j - 1]，操作的最少次数为 <code>dp[i - 1][j - 1] + 2</code></li>
</ul>
<p>最后取最小值，所以当 word1[i - 1] 与 word2[j - 1] 不相同的时候，</p>
<p>递推公式：<code>dp[i][j] = min(&#123;dp[i - 1][j - 1] + 2, dp[i - 1][j] + 1, dp[i][j - 1] + 1&#125;)</code>。</p>
<p>可简化为：<code>dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1)</code>。</p>
</li>
<li>
<p>dp 数组如何初始化</p>
<p><code>dp[i][0] = i</code></p>
<p><code>dp[0][j] = j</code></p>
</li>
<li>
<p>确定遍历顺序</p>
<p>从上到下，从左到右</p>
</li>
<li>
<p>举例推导 dp 数组</p>
<p>​       e a t</p>
<p>​    0 1 2 3</p>
<p>s  1 2 3 4</p>
<p>e  2 1 2 3</p>
<p>a  3 2 1 2</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minDistance</span>(<span class="hljs-params">self, word1, word2</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type word1: str</span><br><span class="hljs-string">        :type word2: str</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        dp = [[<span class="hljs-number">0</span>] * (<span class="hljs-built_in">len</span>(word2) + <span class="hljs-number">1</span>) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(word1) + <span class="hljs-number">1</span>)]<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(word1) + <span class="hljs-number">1</span>):<br>            dp[i][<span class="hljs-number">0</span>] = i<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(word2) + <span class="hljs-number">1</span>):<br>            dp[<span class="hljs-number">0</span>][j] = j<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(word1) + <span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(word2) + <span class="hljs-number">1</span>):<br>                <span class="hljs-keyword">if</span> word1[i - <span class="hljs-number">1</span>] == word2[j - <span class="hljs-number">1</span>]:<br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]<br>                <span class="hljs-keyword">else</span>:<br>                    dp[i][j] = <span class="hljs-built_in">min</span>(dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">2</span>, dp[i - <span class="hljs-number">1</span>][j] + <span class="hljs-number">1</span>, dp[i][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> dp[-<span class="hljs-number">1</span>][-<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure>
<h3 id="72-编辑距离">72. 编辑距离</h3>
<p>动规五部曲：</p>
<ol>
<li>
<p>确定 dp 数组以及下标的含义</p>
<p><code>dp[i][j]</code> 表示以下标 i - 1 为结尾的字符串 word1，和以下标 j - 1 为结尾的字符串 word2，最近编辑距离为 <code>dp[i][j]</code>。</p>
</li>
<li>
<p>确定递推公式</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> word1[i - <span class="hljs-number">1</span>] == word2[j - <span class="hljs-number">1</span>]:<br>    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]<br><span class="hljs-keyword">else</span>:<br>    dp[i][j] = <span class="hljs-built_in">min</span>(dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>], dp[i - <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>]) + <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>
</li>
<li>
<p>dp 数组如何初始化</p>
<p><code>dp[i][j]</code> 表示以下标 i - 1 为结尾的字符串 word1，和以下标 j - 1 为结尾的字符串 word2，最近编辑距离为 <code>dp[i][j]</code>。</p>
<p><code>dp[i][0] = i</code></p>
<p><code>dp[0][j] = j</code></p>
</li>
<li>
<p>确定遍历顺序</p>
<p>从左到右，从上到下</p>
</li>
<li>
<p>举例推导 dp 数组</p>
<p>输入：word1 = “horse”，word2 = “ros”</p>
<p>0 1 2 3</p>
<p>1 1 2 3</p>
<p>2 2 1 2</p>
<p>3 2 2 2</p>
<p>4 3 3 2</p>
<p>5 4 4 3</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minDistance</span>(<span class="hljs-params">self, word1, word2</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type word1: str</span><br><span class="hljs-string">        :type word2: str</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        dp = [[<span class="hljs-number">0</span>] * (<span class="hljs-built_in">len</span>(word2) + <span class="hljs-number">1</span>) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(word1) + <span class="hljs-number">1</span>)]<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(word1) + <span class="hljs-number">1</span>):<br>            dp[i][<span class="hljs-number">0</span>] = i<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(word2) + <span class="hljs-number">1</span>):<br>            dp[<span class="hljs-number">0</span>][j] = j<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(word1) + <span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(word2) + <span class="hljs-number">1</span>):<br>                <span class="hljs-keyword">if</span> word1[i - <span class="hljs-number">1</span>] == word2[j - <span class="hljs-number">1</span>]:<br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]<br>                <span class="hljs-keyword">else</span>:<br>                    dp[i][j] = <span class="hljs-built_in">min</span>(dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>], dp[i - <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>]) + <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> dp[-<span class="hljs-number">1</span>][-<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure>
<h3 id="647-回文子串">647. 回文子串</h3>
<p>动规五部曲：</p>
<ol>
<li>
<p>确定 dp 数组以及下标的含义</p>
<p>布尔类型的 <code>dp[i][j]</code>：表示区间范围 [i, j]（注意是左闭右闭）的子串是否是回文子串，如果是 <code>dp[i][j]</code> 为 true，否则为 false。</p>
</li>
<li>
<p>确定递推公式</p>
<p>整体上是两种，s[i] 与 s[j] 相等，s[i] 与 s[j] 不相等。</p>
<p>当 s[i] 与 s[j] 不相等，<code>dp[i][j]</code> 一定是 false。</p>
<p>当 s[i] 与 s[j] 相等时，有如下三种情况</p>
<ul>
<li>情况一：下标 i 与 j 相同，同一个字符例如 a，当然是回文子串</li>
<li>情况二：下标 i 与 j 相差为 1，例如 aa，也是回文子串</li>
<li>情况三：下标 i 与 j 相差大于 1 的时候，例如 cabac，此时 s[i] 与 s[j] 已经相同了，看 i 到 j 区间是不是回文子串就看 aba 是不是回文就可以，那么 aba 的区间就是 i + 1 与 j - 1 区间，是不是回文就看 <code>dp[i + 1][j - 1]</code> 是否为 true。</li>
</ul>
<p>递推公式：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> s[i] == s[j]:<br>    <span class="hljs-keyword">if</span> j - i &lt;= <span class="hljs-number">1</span>:<br>        result += <span class="hljs-number">1</span><br>        dp[i][j] = true<br>    <span class="hljs-keyword">elif</span> dp[i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]:<br>        result += <span class="hljs-number">1</span><br>        dp[i][j] = true<br></code></pre></td></tr></table></figure>
</li>
<li>
<p>dp 数组如何初始化</p>
<p><code>dp[i][j]</code> 初始化为 false。</p>
</li>
<li>
<p>确定遍历顺序</p>
<p>从上到下，从左到右</p>
</li>
<li>
<p>举例推导 dp 数组</p>
<table>
<thead>
<tr>
<th style="text-align:center">a</th>
<th style="text-align:center">a</th>
<th style="text-align:center">a</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
</tr>
</tbody>
</table>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">countSubstrings</span>(<span class="hljs-params">self, s</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type s: str</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        dp = [[<span class="hljs-number">0</span>] * <span class="hljs-built_in">len</span>(s) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(s))]<br>        res = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(s) - <span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i, <span class="hljs-built_in">len</span>(s)):<br>                <span class="hljs-keyword">if</span> s[i] == s[j]:<br>                    <span class="hljs-keyword">if</span> j - i &lt;= <span class="hljs-number">1</span>:  <span class="hljs-comment"># 情况一和二</span><br>                        res += <span class="hljs-number">1</span><br>                        dp[i][j] = <span class="hljs-literal">True</span><br>                    <span class="hljs-keyword">elif</span> dp[i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]:  <span class="hljs-comment"># 情况三</span><br>                        res += <span class="hljs-number">1</span><br>                        dp[i][j] = <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure>
<h3 id="516-最长回文子序列">516. 最长回文子序列</h3>
<p><strong>回文字串是要连续的，回文子序列不是连续的！</strong></p>
<p>动规五部曲：</p>
<ol>
<li>
<p>确定 dp 数组以及下标的含义</p>
<p><code>dp[i][j]</code>：字符串 s 在 [i, j] 范围内最长的回文子序列的长度为 <code>dp[i][j]</code>。</p>
</li>
<li>
<p>确定递推公式</p>
<p>如果 s[i] 与 s[j] 相同，那么 <code>dp[i][j] = dp[i + 1][j - 1] + 2</code>。</p>
<p>如果 s[i] 与 s[j] 不相同，</p>
<p>加入 s[j] 的回文子序列长度为 <code>dp[i + 1][j]</code>。</p>
<p>加入 s[i] 的回文子序列长度为 <code>dp[i][j - 1]</code>。</p>
<p><code>dp[i][j]</code> 一定取最大的，即：<code>dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])</code>。</p>
</li>
<li>
<p>dp 数组如何初始化</p>
<p><code>dp[i][i] = 1</code></p>
</li>
<li>
<p>确定遍历顺序</p>
<p>从上到下，从左向右</p>
</li>
<li>
<p>举例推导 dp 数组</p>
<table>
<thead>
<tr>
<th style="text-align:center">c</th>
<th style="text-align:center">b</th>
<th style="text-align:center">b</th>
<th style="text-align:center">d</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
</tr>
</tbody>
</table>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">longestPalindromeSubseq</span>(<span class="hljs-params">self, s</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type s: str</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        dp = [[<span class="hljs-number">0</span>] * <span class="hljs-built_in">len</span>(s) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(s))]<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(s)):<br>            dp[i][i] = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(s) - <span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i + <span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(s)):<br>                <span class="hljs-keyword">if</span> s[i] == s[j]:<br>                    dp[i][j] = dp[i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">2</span><br>                <span class="hljs-keyword">else</span>:<br>                    dp[i][j] = <span class="hljs-built_in">max</span>(dp[i + <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>])<br>        <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][-<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure>
<h2 id="单调栈">单调栈</h2>
<p><strong>通常是一维数组，要寻找任一个元素的右边或者左边第一个比自己大或者小的元素的位置，此时就要想到可以用单调栈了。</strong></p>
<p><strong>单调栈的本质是空间换时间</strong>，因为在遍历的过程中需要用一个栈来记录右边第一个比当前元素高的元素，优点是整个数组只需要遍历一次。</p>
<p><strong>直白来说，就是用一个栈来记录遍历过的元素</strong>，因为在遍历数组的时候，不知道之前都遍历了哪些元素，以至于遍历一个元素找不到是不是之前遍历过一个更小的，所以需要用一个容器来记录遍历过的元素。</p>
<ol>
<li>
<p>单调栈里存什么？</p>
<p>单调栈里只需要存放元素的下标 i 就可以了，如果需要使用对应的元素，直接 T[i] 就可以获取。</p>
</li>
<li>
<p>单调栈里元素是递增？还是递减？</p>
<p>如果求一个元素右边第一个更大元素，单调栈就是递增的；如果求一个元素右边第一个更小元素，单调栈就是递减的。</p>
</li>
</ol>
<p>使用单调栈主要有三个判断条件：</p>
<ul>
<li>当前遍历的元素 T[i] &lt; 栈顶元素 T[st.top()] 的情况</li>
<li>当前遍历的元素 T[i] = 栈顶元素 T[st.top()] 的情况</li>
<li>当前遍历的元素 T[i] &gt; 栈顶元素 T[st.top()] 的情况</li>
</ul>
<h3 id="739-每日温度">739. 每日温度</h3>
<p>定义 result 数组的时候，应该直接初始化为 0，如果 result 没有更新，说明这个元素右边没有更大的元素，也就是为 0。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">dailyTemperatures</span>(<span class="hljs-params">self, temperatures</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type temperatures: List[int]</span><br><span class="hljs-string">        :rtype: List[int]</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        ans = [<span class="hljs-number">0</span>] * <span class="hljs-built_in">len</span>(temperatures)<br>        stack = [<span class="hljs-number">0</span>]<br><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(temperatures)):<br>            <span class="hljs-comment"># 情况一和情况二</span><br>            <span class="hljs-keyword">if</span> temperatures[i] &lt;= temperatures[stack[-<span class="hljs-number">1</span>]]:<br>                stack.append(i)<br>            <span class="hljs-comment"># 情况三</span><br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(stack) != <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> temperatures[i] &gt; temperatures[stack[-<span class="hljs-number">1</span>]]:<br>                    ans[stack[-<span class="hljs-number">1</span>]] = i - stack[-<span class="hljs-number">1</span>]<br>                    stack.pop()<br>                stack.append(i)<br>        <span class="hljs-keyword">return</span> ans<br></code></pre></td></tr></table></figure>
<h3 id="496-下一个更大元素Ⅰ">496. 下一个更大元素Ⅰ</h3>
<p>如果不存在对应位置就输出 -1，所以 result 数组如果某位置没有被赋值，就应该是 -1，所以初始化 -1。</p>
<p>在遍历 nums2 的过程中，要判断 nums2[i] 是否在 num1 中出现过，因为最后要根据 nums1 元素的下标来更新 result 数组。</p>
<p>没有重复元素，就可以用 map 来做映射了。根据数值快速找到下标，还可以判断 nums2[i] 是否在 nums1 中出现过。</p>
<p>栈头到栈底的顺序，要从小到大，也就是保持栈里的元素为递增顺序。</p>
<ol>
<li>
<p>情况一：当前遍历的元素 T[i] &lt; 栈顶元素 T[st.top()] 的情况</p>
<p>此时满足递增栈，所以直接入栈</p>
</li>
<li>
<p>情况二：当前遍历的元素 T[i] = 栈顶元素 T[st.top()] 的情况</p>
<p>如果相等依然直接入栈，因为要求的是右边第一个比自己大的元素</p>
</li>
<li>
<p>情况三：当前遍历的元素 T[i] &gt; 栈顶元素 T[st.top()] 的情况</p>
<p>此时如果入栈就不满足递增栈了，判断栈顶元素是否在 nums1 里出现过，如果出现过，开始记录结果。</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">nextGreaterElement</span>(<span class="hljs-params">self, nums1, nums2</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type nums1: List[int]</span><br><span class="hljs-string">        :type nums2: List[int]</span><br><span class="hljs-string">        :rtype: List[int]</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        res = [-<span class="hljs-number">1</span>] * <span class="hljs-built_in">len</span>(nums1)<br>        stack = [<span class="hljs-number">0</span>]<br><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(nums2)):<br>            <span class="hljs-comment"># 情况一和情况二</span><br>            <span class="hljs-keyword">if</span> nums2[i] &lt;= nums2[stack[-<span class="hljs-number">1</span>]]:<br>                stack.append(i)<br>            <span class="hljs-comment"># 情况三</span><br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(stack) != <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> nums2[i] &gt; nums2[stack[-<span class="hljs-number">1</span>]]:<br>                    <span class="hljs-keyword">if</span> nums2[stack[-<span class="hljs-number">1</span>]] <span class="hljs-keyword">in</span> nums1:<br>                        index = nums1.index(nums2[stack[-<span class="hljs-number">1</span>]])<br>                        res[index] = nums2[i]<br>                    stack.pop()<br>                stack.append(i)<br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure>
<h3 id="503-下一个更大元素Ⅱ">503. 下一个更大元素Ⅱ</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">nextGreaterElements</span>(<span class="hljs-params">self, nums</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type nums: List[int]</span><br><span class="hljs-string">        :rtype: List[int]</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        res = [-<span class="hljs-number">1</span>] * <span class="hljs-built_in">len</span>(nums)<br>        stack = [<span class="hljs-number">0</span>]<br><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums) * <span class="hljs-number">2</span>):<br>            <span class="hljs-keyword">while</span> (<span class="hljs-built_in">len</span>(stack) != <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> nums[i % <span class="hljs-built_in">len</span>(nums)] &gt; nums[stack[-<span class="hljs-number">1</span>]]):<br>                res[stack[-<span class="hljs-number">1</span>]] = nums[i % <span class="hljs-built_in">len</span>(nums)]<br>                stack.pop()<br>            stack.append(i % <span class="hljs-built_in">len</span>(nums))<br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure>
<h3 id="42-接雨水">42. 接雨水</h3>
<p>单调栈就是保持栈内元素有序。接雨水正需要寻找一个元素，右边最大元素以及左边最大元素，来计算雨水面积。</p>
<ol>
<li>
<p>首先单调栈是按行方向来计算雨水</p>
</li>
<li>
<p>使用单调栈内元素的顺序</p>
<p>从栈头（元素从栈头弹出）到栈底的顺序应该是从小到大的顺序。</p>
</li>
<li>
<p>遇到相同高度的柱子怎么办？</p>
<p>遇到相同元素，更新栈内下标，就是将栈里元素（旧下标）弹出，将新元素（新下标）加入栈中。</p>
<p><strong>因为要求宽度的时候，如果遇到相同高度的柱子，需要使用最右边的柱子来计算宽度。</strong></p>
</li>
<li>
<p>栈里要保存什么数值</p>
<p>使用单调栈，也是通过长 * 宽来计算雨水面积的。</p>
<p>长就是通过柱子的高度来计算，宽就是通过柱子之间的下标来计算。</p>
</li>
</ol>
<p>以下逻辑主要有三种情况：</p>
<ul>
<li>情况一：当前遍历的元素（柱子）高度 &lt; 栈顶元素的高度 height[i] &lt; height[st.top()]</li>
<li>情况二：当前遍历的元素（柱子）高度 = 栈顶元素的高度 height[i] == height[st.top()]</li>
<li>情况三：当前遍历的元素（柱子）高度 &gt; 栈顶元素的高度 height[i] &gt; height[st.top()]</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">trap</span>(<span class="hljs-params">self, height</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type height: List[int]</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        res = <span class="hljs-number">0</span><br>        stack = [<span class="hljs-number">0</span>]<br><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(height)):<br>            <span class="hljs-comment"># 情况一</span><br>            <span class="hljs-keyword">if</span> height[i] &lt; height[stack[-<span class="hljs-number">1</span>]]:<br>                stack.append(i)<br><br>            <span class="hljs-comment"># 情况二</span><br>            <span class="hljs-keyword">elif</span> height[i] == height[stack[-<span class="hljs-number">1</span>]]:<br>                stack.pop()<br>                stack.append(i)<br>            <br>            <span class="hljs-comment"># 情况三</span><br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">while</span> stack <span class="hljs-keyword">and</span> height[i] &gt; height[stack[-<span class="hljs-number">1</span>]]:<br>                    <span class="hljs-comment"># 栈顶就是中间柱子</span><br>                    mid_height = height[stack[-<span class="hljs-number">1</span>]]<br>                    stack.pop()<br>                    <span class="hljs-keyword">if</span> stack:<br>                        right_height = height[i]<br>                        left_height = height[stack[-<span class="hljs-number">1</span>]]<br>                        <span class="hljs-comment"># 两侧的较矮一方的高度 - 凹槽底部高度</span><br>                        h = <span class="hljs-built_in">min</span>(right_height, left_height) - mid_height<br>                        <span class="hljs-comment"># 凹槽右侧下标 - 凹槽左侧下标 - 1：只求中间宽度</span><br>                        w = i - stack[-<span class="hljs-number">1</span>] - <span class="hljs-number">1</span><br>                        <span class="hljs-comment"># 体积：高 * 宽</span><br>                        res += h * w<br>                stack.append(i)<br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure>
<h3 id="84-柱状图中最大的矩形">84. 柱状图中最大的矩形</h3>
<p>本题要找每个柱子左右两边第一个小于该柱子的柱子，所以从栈头（元素从栈头弹出）到栈底的顺序应该是从大到小的顺序。</p>
<p>只有栈里从大到小的顺序，才能保证栈顶元素找到左右两边第一个小于栈顶元素的柱子。</p>
<p>本题单调栈的顺序正好与接雨水反过来。</p>
<p><strong>栈顶和栈底的下一个元素以及要入栈的三个元素组成了要求最大面积的高度和宽度</strong>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">largestRectangleArea</span>(<span class="hljs-params">self, heights</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type heights: List[int]</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        res = <span class="hljs-number">0</span><br>        stack = [<span class="hljs-number">0</span>]<br>        <span class="hljs-comment"># 输入数组首尾各补上一个0，原首尾两个柱子可作为核心柱进行最大面积尝试</span><br>        heights.insert(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<br>        heights.append(<span class="hljs-number">0</span>)<br><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(heights)):<br>            <span class="hljs-comment"># 情况一</span><br>            <span class="hljs-keyword">if</span> heights[i] &gt; heights[stack[-<span class="hljs-number">1</span>]]:<br>                stack.append(i)<br>            <br>            <span class="hljs-comment"># 情况二</span><br>            <span class="hljs-keyword">elif</span> heights[i] == heights[stack[-<span class="hljs-number">1</span>]]:<br>                stack.pop()<br>                stack.append(i)<br>            <br>            <span class="hljs-comment"># 情况三</span><br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">while</span> stack <span class="hljs-keyword">and</span> heights[i] &lt; heights[stack[-<span class="hljs-number">1</span>]]:<br>                    <span class="hljs-comment"># 栈顶就是中间的柱子</span><br>                    mid_height = stack[-<span class="hljs-number">1</span>]<br>                    stack.pop()<br>                    <span class="hljs-keyword">if</span> stack:<br>                        left_height = stack[-<span class="hljs-number">1</span>]<br>                        right_height = i<br>                        width = right_height - left_height - <span class="hljs-number">1</span><br>                        height = heights[mid_height]<br>                        res = <span class="hljs-built_in">max</span>(res, width * height)<br>                stack.append(i)<br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure>
<h2 id="背包问题">背包问题</h2>
<h3 id="二维">二维</h3>
<p>有 n 件物品和一个最多能背重量为 w 的背包。第i件物品的重量是 weight[i]，得到的价值是 value[i] 。<strong>每件物品只能用一次</strong>，求解将哪些物品装入背包里物品价值总和最大。</p>
<p>动态规划五部曲：</p>
<ol>
<li>
<p>确定 dp 数组以及下标的含义</p>
<p>i 表示物品、j 表示背包容量</p>
<p><code>dp[i][j]</code>：表示从下标为 [0 - i] 的物品里任意取，放进容量为 j 的背包，价值总和最大是多少。</p>
</li>
<li>
<p>确定递推公式</p>
<p>不放物品 i：背包容量为 j，里面不放物品 i 的最大价值是 <code>dp[i - 1][j]</code>。</p>
<p>放物品 i：背包空出物品 i 的容量后，背包容量为 <code>j - weight[i]</code>，<code>dp[i - 1][j - weight[i]]</code>为背包容量 <code>j - weight[i]</code> 且不放物品 i 的最大价值，那么 <code>dp[i - 1][j - weight[i]] + value[i]</code>(物品的价值)，就是背包放物品 i 得到的最大价值。</p>
<p>递归公式：<code>dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i])</code></p>
</li>
<li>
<p>dp 数组如何初始化</p>
<p><code>dp[i][0]</code> = 0, <code>dp[0][j]</code> = value[0]</p>
</li>
<li>
<p>确定遍历顺序</p>
<p>先遍历物品，再遍历背包重量。</p>
</li>
<li>
<p>举例推导 dp 数组</p>
<table>
<thead>
<tr>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>15</td>
<td>15</td>
<td>15</td>
<td>15</td>
</tr>
<tr>
<td>0</td>
<td>15</td>
<td>15</td>
<td>20</td>
<td>15</td>
</tr>
<tr>
<td>0</td>
<td>15</td>
<td>15</td>
<td>20</td>
<td>35</td>
</tr>
</tbody>
</table>
</li>
</ol>
<h3 id="一维">一维</h3>
<p>在使用二维数组的时候，递推公式：<code>dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i])</code></p>
<p><strong>其实可以发现如果把 dp[i - 1] 那一层拷贝到 dp[i] 上，表达式完全可以是：<code>dp[i][j] = max(dp[i][j], dp[i][j - weight[i]] + value[i])</code></strong></p>
<p><strong>与其把 dp[i - 1] 这一层拷贝到 dp[i] 上，不如只用一个一维数组</strong>（一维数组也可以理解为一个滚动数组）。</p>
<p>动规五部曲：</p>
<ol>
<li>
<p>确定 dp 数组的定义</p>
<p>在一堆 dp 数组中，dp[j] 表示：容量为 j 的背包，所背的物品价值可以最大为 dp[j]。</p>
</li>
<li>
<p>一维 dp 数组的递推公式</p>
<p>递推公式为：<code>dp[j] = max(dp[j], dp[j - weight[i]] + value[i])</code></p>
</li>
<li>
<p>一维 dp 数组如何初始化</p>
<p><strong>关于初始化，一定要和 dp 数组的定义吻合，否则到递推公式的时候就会越来越乱。</strong></p>
<p>假设物品价值都是大于 0 的，所以 dp 数组初始化的时候，都初始化为 0 就可以了。</p>
</li>
<li>
<p>遍历顺序</p>
<p>二维 dp 遍历的时候，背包容量从小到大，而一维 dp 遍历的时候，背包是从大到小。</p>
<p>举例：物品 0 的重量 weight[0] = 1，价值 value[0] = 15</p>
<p>正序遍历：</p>
<p>dp[1] = dp[1 - weight[0]] + value[0] = 15</p>
<p>dp[2] = dp[2 - weight[0]] + value[0] = 30</p>
<p>此时 dp[2] 就已经是 30 了，意味着物品 0 被放入了两次，所以不能正序遍历。</p>
<p>倒序遍历：</p>
<p>dp[2] = dp[2 - weight[0]] + value[0] = 15 （dp数组已经都初始化为0）</p>
<p>dp[1] = dp[1 - weight[0]] + value[0] = 15</p>
<p>所以从后往前循环，每次取得状态不会和之前取得状态重合，这样每种物品就只取一次了。</p>
</li>
<li>
<p>举例推导 dp 数组</p>
<p>用物品 0，遍历背包：0 15 15 15 15</p>
<p>用物品 1，遍历背包：0 15 15 20 35</p>
<p>用物品 2，遍历背包：0 15 15 20 35</p>
</li>
</ol>
<h3 id="完全背包">完全背包</h3>
<p>完全背包和 0-1 背包问题唯一不同的地方就是每种物品有无限件。</p>
<p>动规五部曲：</p>
<ol>
<li>
<p>确定 dp 数组的定义</p>
<p><code>dp[i][j]</code> 表示从下标为 [0-i] 的物品，每个物品可以取无限次，放进容量为 j 的背包，价值总和最大是多少。</p>
</li>
<li>
<p>一维 dp 数组的递推公式</p>
<p>不放物品 i：背包容量为 j，里面不放物品 i 的最大价值是 <code>dp[i - 1][j]</code></p>
<p>放物品 i：背包空出物品 i 的容量后，背包容量为 <code>j - weight[i]</code>，<code>dp[i - 1][j - weight[i]]</code>为背包容量 <code>j - weight[i]</code> 且不放物品 i 的最大价值，那么 <code>dp[i - 1][j - weight[i]] + value[i]</code>(物品的价值)，就是背包放物品 i 得到的最大价值。</p>
<p>递推公式为：<code>dp[i][j] = max(dp[i - 1][j], dp[i][j - weight[i]] + value[i])</code></p>
</li>
<li>
<p>dp 数组如何初始化</p>
<p><strong>关于初始化，一定要和 dp 数组的定义吻合，否则到递推公式的时候就会越来越乱。</strong></p>
<p><code>dp[i][0] = 0</code>, <code>dp[0][j] = dp[0][j - weight[0]] + value[0]</code></p>
</li>
<li>
<p>遍历顺序</p>
<p>既可以先遍历物品再遍历背包，也可以先遍历背包再遍历物品。</p>
</li>
<li>
<p>举例推导 dp 数组</p>
<p>用物品 0，遍历背包：0 15 30 45 60</p>
<p>用物品 1，遍历背包：0 15 30 45 60</p>
<p>用物品 2，遍历背包：0 15 30 45 60</p>
<p>因为物品 0 的性价比最高，而且在完全背包中，每一类物品都有无限个，所以有无限个物品 0，既然物品 0 性价比最高，当然优先放物品 0。</p>
</li>
</ol>
<h2 id="图论">图论</h2>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E7%AE%97%E6%B3%95/" class="category-chain-item">算法</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/Algorithm/" class="print-no-link">#Algorithm</a>
      
        <a href="/tags/LeetCode/" class="print-no-link">#LeetCode</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>LeetCode Notes</div>
      <div>https://www.renkelin.vip/2025/02/15/Algorithm-note/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>Author</div>
          <div>Kolin</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>Posted on</div>
          <div>February 15, 2025</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>Licensed under</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - Attribution">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2025/02/19/DL-RS/" title="Deep Learning Recommender System">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Deep Learning Recommender System</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/01/12/SLM/" title="Statistical Learning Method">
                        <span class="hidden-mobile">Statistical Learning Method</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments" lazyload>
      
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://lib.baomitu.com/valine/1.5.1/Valine.min.js', function() {
        var options = Object.assign(
          {"appId":"VNSy36PGiQCPwyRb6AukmG4w-gzGzoHsz","appKey":"yzHhLZjFMNqrtHhPeHVoWzF2","path":"window.location.pathname","placeholder":null,"avatar":"retro","meta":["nick","mail","link"],"requiredFields":[],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":"","emojiCDN":null,"emojiMaps":null,"enableQQ":false},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
        Fluid.utils.waitElementVisible('#valine .vcontent', () => {
          var imgSelector = '#valine .vcontent img:not(.vemoji)';
          Fluid.plugins.imageCaption(imgSelector);
          Fluid.plugins.fancyBox(imgSelector);
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>Table of Contents</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">Keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="mailto:renkelin00@gmail.com?subject=Interested+In+Your+Blog" target="_blank" rel="nofollow noopener"><span>Contact me</span></a> <i class="iconfont icon-love"></i> <a href="mailto:renkelin00@gmail.com?subject=Interested+In+Your+Blog" target="_blank" rel="nofollow noopener"><span>renkelin00@gmail.com</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        总访问量 
        <span id="busuanzi_value_site_pv"></span>
         次
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        总访客数 
        <span id="busuanzi_value_site_uv"></span>
         人
      </span>
    
    
  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">Blog works best with JavaScript enabled</div>
  </noscript>
</body>
</html>
